#!/bin/bash

 # fetch - search, install, create, remove, upgrade packages in ChiliOS
 #
 # Created: 2019/04/05
 # Altered: 2020/08/24
 #
 # Copyright (c) 2019 - 2019, Vilmar Catafesta <vcatafesta@gmail.com>
 # All rights reserved.
 #
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions
 # are met:
 # 1. Redistributions of source code must retain the above copyright
 #    notice, this list of conditions and the following disclaimer.
 # 2. Redistributions in binary form must reproduce the above copyright
 #    notice, this list of conditions and the following disclaimer in the
 #    documentation and/or other materials provided with the distribution.
 # 3. The name of the copyright holders or contributors may not be used to
 #    endorse or promote products derived from this software without
 #    specific prior written permission.
 #
 # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 # ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 # PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
 # HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#########################################################################
_VERSION_="2.03.01.20200824"
# awk -F: '{print $1}' /var/cache/fetch/search/packages-split | grep ^python$

#fatorial
#seq -s* 6 | bc
#cat <(echo xxx; sleep 3; echo yyy; sleep 3)
#ls | cut -d. -sf2-  | sort | uniq -c
#source=($pkgname-${pkgver//_/-}.tar.gz)
readonly DEPENDENCIES=(which tar zstd curl sed grep cat awk tput dialog)
IFS=$' \t\n'
SAVEIFS=$IFS

#hex code
barra=$'\x5c'
check=$'\0xfb'
reg=$'\0x2a'
SYSCONFDIR='/etc/fetch'
NORMAL="\\033[0;39m"         # Standard console grey
SUCCESS="\\033[1;32m"        # Success is green
WARNING="\\033[1;33m"        # Warnings are yellow
FAILURE="\\033[1;31m"        # Failures are red
INFO="\\033[1;36m"           # Information is light cyan
BRACKET="\\033[1;34m"        # Brackets are blue
BMPREFIX="     "
SUCCESS_PREFIX="${SUCCESS}  *  ${NORMAL}"
FAILURE_PREFIX="${FAILURE}*****${NORMAL}"
WARNING_PREFIX="${WARNING}  W  ${NORMAL}"
SKIP_PREFIX="${INFO}  S  ${NORMAL}"
SUCCESS_SUFFIX="${BRACKET}[${SUCCESS}  OK  ${BRACKET}]${NORMAL}"
FAILURE_SUFFIX="${BRACKET}[${FAILURE} FAIL ${BRACKET}]${NORMAL}"
WARNING_SUFFIX="${BRACKET}[${WARNING} WARN ${BRACKET}]${NORMAL}"
SKIP_SUFFIX="${BRACKET}[${INFO} SKIP ${BRACKET}]${NORMAL}"
WAIT_PREFIX="${WARNING}  R  ${NORMAL}"
WAIT_SUFFIX="${BRACKET}[${WARNING} WAIT ${BRACKET}]${NORMAL}"
FAILURE_PREFIX="${FAILURE}  X  ${NORMAL}"
BOOTLOG=/tmp/fetchlog-$USER
KILLDELAY=3
SCRIPT_STAT="0"

if [ -z "${COLUMNS}" ]; then
   COLUMNS=$(stty size)
   COLUMNS=${COLUMNS##* }
fi
if [ "${COLUMNS}" = "0" ]; then
   COLUMNS=80
fi

COL=$((${COLUMNS} - 8))
WCOL=$((${COL} - 2))
SET_COL="\\033[${COL}G"      # at the $COL char
SET_WCOL="\\033[${WCOL}G"    # at the $WCOL char
CURS_UP="\\033[1A\\033[0G"   # Up one line, at the 0'th char
CURS_ZERO="\\033[0G"

OK=1
NOK=0
true=1
TRUE=1
false=0
FALSE=0
LINSTALLED=2
LREMOVED=3

# flag's para split package
: ${aPKGSPLIT=()}
: ${aPKGLIST=}
: ${PKG_FOLDER_DIR=0}
: ${PKG_FULLNAME=1}
: ${PKG_ARCH=2}
: ${PKG_BASE=3}
: ${PKG_BASE_VERSION=4}
: ${PKG_VERSION=5}
: ${PKG_BUILD=6}

# SUBROUTINES

function cpad()
{ # centralizar string
	COLS=$(tput cols)
	printf "%*s\n" $[$COLS/2] "${1}"
}

function rpad()
{ # justificar à direita
	COLS=$(tput cols)
	printf "%*s\n" $COLS "${1}"
}

function lpad()
{ # justificar à esquerda + $2 espacos
	COLS=$(tput cols)
	printf "%ds\n" ${2} "${1}"
}

function sh_cdroot()
{
	cd - >/dev/null 2>&1
}

function colorize()
{
    if tput setaf 0 &>/dev/null; then
        ALL_OFF="$(tput sgr0)"
        BOLD="$(tput bold)"
        BLUE="${BOLD}$(tput setaf 4)"
        GREEN="${BOLD}$(tput setaf 2)"
        RED="${BOLD}$(tput setaf 1)"
        YELLOW="${BOLD}$(tput setaf 3)"
    else
        ALL_OFF="\e[0m"
        BOLD="\e[1m"
        BLUE="${BOLD}\e[34m"
        GREEN="${BOLD}\e[32m"
        RED="${BOLD}\e[31m"
        YELLOW="${BOLD}\e[33m"
    fi
    readonly ALL_OFF BOLD BLUE GREEN RED YELLOW
}

function plain()
{
    local mesg=$1; shift
    printf "${BOLD}    ${mesg}${ALL_OFF}\n" "$@" >&2
}

function msg()
{
    local mesg=$1; shift
    printf "${GREEN}  =>${ALL_OFF}${BOLD} ${mesg}${ALL_OFF}\n" "$@" >&2
}

function msg2()
{
    local mesg=$1; shift
    printf "${BLUE}  ->${ALL_OFF}${BOLD} ${mesg}${ALL_OFF}\n" "$@" >&2
}

function warning()
{
    local mesg=$1; shift
    printf "${YELLOW}==> $(gettext "WARNING:")${ALL_OFF}${BOLD} ${mesg}${ALL_OFF}\n" "$@" >&2
}

function error()
{
    local mesg=$1; shift
    printf "${RED}==> $(gettext "ERROR:")${ALL_OFF}${BOLD} ${mesg}${ALL_OFF}\n" "$@" >&2
}

function timespec()
{
   STAMP="$(echo `date +"%b %d %T %:z"` `hostname`) "
   return 0
}

function log_msg()
{
    echo -n -e "${BMPREFIX}${@}\n"
    return 0
}

function log_info_msg()
{
    echo -n -e "${BMPREFIX}${@}"
    logmessage=`echo "${@}" | sed 's/\\\033[^a-zA-Z]*.//g'`
    timespec
    echo -n -e "${STAMP} ${logmessage}" >> ${BOOTLOG}
    return 0
}

function log_warning_msg()
{
    echo -n -e "${BMPREFIX}${@}"
    echo -e "${CURS_ZERO}${WARNING_PREFIX}${SET_COL}${WARNING_SUFFIX}"

    # Strip non-printable characters from log file
    logmessage=`echo "${@}" | sed 's/\\\033[^a-zA-Z]*.//g'`
    timespec
    echo -e "${STAMP} ${logmessage} WARN" >> ${BOOTLOG}
    return 0
}


function log_failure_msg()
{
    echo -n -e "${BMPREFIX}${@}"
    echo -e "${CURS_ZERO}${FAILURE_PREFIX}${SET_COL}${FAILURE_SUFFIX}"
    echo "FAIL" >> ${BOOTLOG}
    return 0
}


function log_failure_msg2()
{
    echo -n -e "${BMPREFIX}${@}"
    echo -e "${CURS_ZERO}${FAILURE_PREFIX}${SET_COL}${FAILURE_SUFFIX}"
    echo "FAIL" >> ${BOOTLOG}
    return 0
}


function log_success_msg2()
{
    echo -n -e "${BMPREFIX}${@}"
    echo -e "${CURS_ZERO}${SUCCESS_PREFIX}${SET_COL}${SUCCESS_SUFFIX}"
    echo " OK" >> ${BOOTLOG}
    return 0
}


function log_wait_msg()
{
    echo -n -e "${BMPREFIX}${@}"
    echo -e "${CURS_ZERO}${WAIT_PREFIX}${SET_COL}${WAIT_SUFFIX}"
    echo " OK" >> ${BOOTLOG}
    return 0
}


function evaluate_retval()
{
   local error_value="${?}"

	if [ ${error_value} = 0 ]; then
		log_success_msg2
	else
		log_failure_msg2
	fi
	return ${error_value}
}


function sh_checkparametros()
{
    LAUTO=$false
    LFORCE=$false
    LLIST=$true
    local param=$@
    local s

    for s in ${param[@]}
    do
        [[ $(toupper "${s}") = "-Y" ]] && LAUTO=$true
        [[ $(toupper "${s}") = "-F" ]] && LFORCE=$true
        [[ $(toupper "${s}") = "OFF" ]] && LLIST=$false
    done
}


function info()
{
    dialog 				\
    --beep				\
    --title     "FETCH"	\
    --backtitle "fetch"	\
    --msgbox    "$*"	\
    15 70
}

# Módulo para emular o comando cat
function _CAT()
{
    # Tag para sinalizar que precisa parar.
    local end_of_file='EOF'

    INPUT=( "${@:-"%"}" )
    for i in "${INPUT[@]}"; do
        if [[ "$i" != "%" ]]; then
            exec 3< "$i" || exit 1
        else
            exec 3<&0
        fi
        while read -ru 3; do
            # END OF FILE. Para identificar que precisa parar.
            [[ "$REPLY" = "$end_of_file" ]] && break
            echo -E "$REPLY"
        done
    done
}

# Módulo para emular o grep
function _GREP()
{
    # Se encontrar a linha ele retorna a expressão encontrada! com status 0
    # se não é status 1.
    # Para utilizar este módulo precisa ser passado o argumento seguido do arquivo.
    # ou variável.
    local expression="$1"
    local receive="$2"

    # Testando e buscando expressão.
    if [[ -z "$expression" ]]; then
        { echo 'MODULE _GREP ERROR. Not found variable $expression'; exit 1 ;}
    elif [[ -z "$receive" ]]; then
        { echo 'MODULE _GREP ERROR. Not found variable $receive'; exit 1 ;}
    fi
    while IFS= read line; do
        [[ "$line" =~ $expression ]] && { echo "$line"; return 0;}
    done < "$receive"
	 IFS=$SAVEIFS
    return 1
}

# Módulo para emular o comando wc
# Está funcionando por enquanto somente para
# linhas.
function _WC()
{
    local check="$@" # Recebendo args
    local inc='0'    # Var incremento

    for x in $check; do
        let inc++
    done
    echo "$inc"
    return 0
}


function sh_touchconf()
{
	mkdir -p $SYSCONFDIR &> /dev/null
	cat > $SYSCONFDIR/fetch.conf << '_EOF_'
######################################################################
# Arquivo de configuracao
######################################################################

# extensao dos pacotes: chilios=chi.zst, mazon=mz
#PKG_EXT='mz'			#mazonos
PKG_EXT='chi.zst'		#ChiliOS

# site de hospedagem da distro
#PKG_SITE='http://10.0.0.68'
#PKG_SITE='http://201.7.66.107'
#PKG_SITE='http://mazonos.com'
PKG_SITE='https://github.com/vcatafesta/ChiliOS/tree/master'
PKG_RAW_FILE='https://raw.githubusercontent.com/vcatafesta/ChiliOS/master/packages/t/tree-1.8.0-2.chi.zst'
PKG_RAW='https://raw.githubusercontent.com/vcatafesta/ChiliOS/master'
AUTO_YES='1'
MAINTAINER='Vilmar Catafesta <vcatafesta@gmail.com>'
GPG_SIGN='0'
DESC_BUILD='2'
REWRITE_SIG='1'
URL='http://www.linuxfromscratch.org/lfs/view/systemd/'
LICENSE='GPL2'
LFS_VERSION='8.4'
LFS_INIT='SYSTEMD'
ARCH='x86_64'
DISTRO='chili'
LFS_VARCACHE='fetch'
PKGDIR='/var/cache/fetch/archives'
GITDIR='/github/ChiliOS'
ALIEN_CACHE_DIR='/var/cache/pacman/pkg'
IGNOREPKG=('glibc' 'file')

# pacotes hospedado no repositorio do github: sim='1', nao='0'
GITSITE='1'
_EOF_
}

fc=$SYSCONFDIR/fetch.conf
test -e "$fc" || sh_touchconf
source /etc/fetch/fetch.conf &> /dev/null

# default
export APP="fetch"
PRG="${PKG_EXT:=chi.zst}"
SITE="${PKG_SITE:=http://10.0.0.66}"
GITSITE="${GITSITE:=0}"
RAW="${PKG_RAW:=http://10.0.0.66}"
AUTO_YES="${AUTO_YES:=1}"
VARCACHE="/var/cache/${APP}"
VARCACHE_ARCHIVES="/var/cache/${APP}/archives"
VARCACHE_REMOVED="/var/cache/${APP}/removed"
VARCACHE_INSTALLED="/var/cache/${APP}/installed"
VARCACHE_SEARCH="/var/cache/${APP}/search"
LIBRARY=${LIBRARY:-'/usr/share/${APP}'}
#
export descme='info/desc'
export PKG_EXT="${PKG_EXT:='chi.zst'}"
export LFS_VARCACHE="${LFS_VARCACHE:='fetch'}"
export VARLIB_LIST="/var/cache/${APP}/list"
export VARLIB_DESC="/var/cache/${APP}/desc"
export VARLIB_REMO="/var/cache/${APP}/remove"

declare -l BAIXA=${MENSAGEM}
declare -u ALTA=${MENSAGEM}


function importlib()
{
	for lib in "$LIBRARY"/*.sh; do
		source "$lib"
	done
}

function toupper()
{
    declare -u TOUPPER=${@}
    echo ${TOUPPER}
}

function tolower()
{
    declare -l TOLOWER=${@}
    echo ${TOLOWER}
}

function now()
{
    printf "%(%m-%d-%Y %H:%M:%S)T\n" $(date +%s)
}

function strzero()
{
    printf "%0*d" $2 $1
}

function replicate()
{
    for c in $(seq 1 $2);
    do
        printf "%s" $1
    done
}


function maxcol()
{
	if [ -z "${COLUMNS}" ]; then
		COLUMNS=$(stty size)
		COLUMNS=${COLUMNS##* }
	fi
	return $COLUMNS
}


function inkey()
{
	read -t "$1" -n1 -r -p "" lastkey
}


# simulando bash com echo
# Vilmar Catafesta <vcatafesta@gmail.com>
function _cat()
{
	echo "$(<$1)"
}


function setvarcolors()
{
	if tput setaf 1 &> /dev/null; then
		tput sgr0; # reset colors
		bold=$(tput bold);
		reset=$(tput sgr0);
		black=$(tput setaf 0);
		blue=$(tput setaf 33);
		cyan=$(tput setaf 37);
		green=$(tput setaf 64);
		orange=$(tput setaf 166);
		purple=$(tput setaf 125);
		red=$(tput setaf 124);
		violet=$(tput setaf 61);
		white=$(tput setaf 15);
		yellow=$(tput setaf 136);
		pink="\033[35;1m";
	else
		bold='';
		reset="\e[0m";
		black="\e[1;30m";
		blue="\e[1;34m";
		cyan="\e[1;36m";
		green="\e[1;32m";
		orange="\e[1;33m";
		purple="\e[1;35m";
		red="\e[1;31m";
		violet="\e[1;35m";
		white="\e[1;37m";
		yellow="\e[1;33m";
		pink="\033[35;1m";
	fi
}


function sh_msgdoevangelho()
{
    local total
    local id
    local msg

    frases=(
        "Seja fiel até a morte, e eu te darei a coroa da vida! Ap 2:10"
        "O que adianta o homem ganhar o mundo inteiro e perder sua alma?"
        "Deus está com você!"
        "Deus não falha!"
        "A recompensa é boa!"
        "A recompensa é eterna!"
        "As dificuldades e os sofrimentos vão passar"
        "Não desista, Deus tem grandes planos para você"
    )
    total=${#frases[@]}
    id=$(( $RANDOM % $total ))
    msg="${frases[$id]}"
    echo -e "${blue}${msg}${reset}\n"
}


function sh_list()
{
	local param=$@
	local s
	LLIST=$true
	LFORCE=$false
	pkg=

	sh_checkdir "OFF"

	if (( $LLIST )); then
		log_wait_msg "${blue}Reading package lists in the repository..."
	fi

	if [[ "${param}" == "" ]] || [[ $(toupper "${param}") = "ALL" ]] || [[ $(toupper "${param}") = "ALL OFF" ]]; then
		LALL=$true
		pkg=$(_CAT $VARCACHE_SEARCH/folders_packages)
	else
		for s in ${param[@]}; do
			if [[ $(toupper "${s}") = "-Y" ]]; then
				shift
				LAUTO=$true
			elif [[ $(toupper "${s}") = "-F" ]]; then
				shift
				LFORCE=$true
			elif [[ $(toupper "${s}") = "OFF" ]]; then
				LLIST=$false
			else
				pkg="$pkg $(grep $s $VARCACHE_SEARCH/folders_packages)"
			fi
		done
	fi
	param="$@"


	if (( $LLIST )); then
		log_wait_msg "${blue}Listing..."
		pkgCheckNumber=0
		printf "%12sPackage(${ncontapkgdep})%34sversion%8sfullname\n"
		if [[ $pkg ]]; then
			for i in $pkg; do
				((pkgCheckNumber++))
				sh_splitpkg $i
				[[ $LLIST = $true ]] && printf "${green}%s(%04d) ${orange}%-43s ${reset}%-15s%s\n" "     " "$pkgCheckNumber" "${aPKGSPLIT[$PKG_BASE]}" "${aPKGSPLIT[$PKG_VERSION]}" "${aPKGSPLIT[$PKG_FOLDER_DIR]}/${aPKGSPLIT[$PKG_FULLNAME]}"
			done
			[[ $LLIST = $true ]] && log_msg "${green}($pkgCheckNumber)${reset} package(s) found."
		else
			log_failure_msg2 "${red}$param NOT FOUND ${reset} ${orange}$i${reset}"
			log_failure_msg2 "($pkgCheckNumber) package(s) found."
			echo
			echo -e "${reset}Use: # $0 update - to update with the repository${reset}"
		fi
	fi
	sh_cdroot
}


function sh_checknet()
{
	# have internet?
	log_info_msg "${cyan}Testing internet"
	#ping -c3 -q $(echo $SITE | sed 's/http:\/\///g') >/dev/null 2>&1 || { evaluate_retval; log_failure_msg2 "No route to server ($SITE) - ABORTED."; return 1 ;}
	curl --insecure $SITE >/dev/null 2>&1 || { evaluate_retval; log_failure_msg2 "No route to server ($SITE) - ABORTED."; return 1 ;}
	evaluate_retval
	return $?
}


function sh_selfupdate()
{
	local param=$@
	sh_checkparametros ${param}
	if !(( $LAUTO )) || !(( $LFORCE)); then
		echo
		conf "Update $0 from internet?"
		LAUTO=$?
	fi

	if (( $LAUTO )) || (( $LFORCE )); then
		local link='https://raw.githubusercontent.com/vcatafesta/ChiliOS/master/updater/fetch'
		local tmp_dir_full="/tmp/${APP}"
		local tmp_dir="/tmp/${APP}/src"
		local m

		#internet?
		sh_checknet; [[ $? = $false ]] || { return 1;}
		log_wait_msg "Ok, let's do it..."
		#Ok, Puxe o arquivo do repositorio agora!
		[[ -d "${tmp_dir_full}" ]] && rm -r "${tmp_dir_full}"
		[[ -d "${tmp_dir}" ]] || mkdir -p "${tmp_dir}"
		pushd "${tmp_dir}" &>/dev/null
		log_info_msg "${cyan}Clonando $link"
		curl --insecure --silent --remote-name "${link}"
		evaluate_retval

		log_info_msg "${cyan}Permission and Copy archives"
		chmod +x ${tmp_dir}/fetch
		evaluate_retval

		log_info_msg "${cyan}Copying file ${yellow}fetch ${red}to ${yellow}/sbin/$m"
		cp -f ${tmp_dir}/fetch /sbin/fetch
		ln -sf /sbin/fetch /sbin/apt
		evaluate_retval

		log_info_msg "${cyan}Removing temporary files"
		[[ -d "${tmp_dir_full}" ]] && rm -r "${tmp_dir_full}"
		evaluate_retval
		log_info_msg "${violet}$0 updated successfully, enjoy!"
		evaluate_retval
		exit 0
	fi
	return 1
	sh_cdroot
}


function spinner()
{
	spin=('\' '|' '/' '-' '+')

	while :; do
		for i in "${spin[@]}"; do
			echo -ne "${cyan}\r$i${reset}"
			#sleep 0.1
		done
	done
}


function sh_checkroot()
{
	if [ "$(id -u)" != "0" ]; then
		log_failure_msg2 "ERROR: This script must be run with root privileges."
		exit
	fi
}


function sh_version()
{
	echo -e "$0 $_VERSION_"
	echo
}


function help()
{
	echo -e "${cyan}Most used commands:"
	echo -e "${pink}  -h, --help,           help           ${reset}- display this help and exit"
	echo -e "${pink}  -Sa, --alienpkg,      alienpkg       ${reset}- import package from ARCH"
	echo -e "${pink}  -Sl, --local,         local          ${reset}- install local package"
	echo -e "${pink}  -c  --create,         create         ${reset}- build package"
	echo -e "${pink}  -Sg, --generate,      generate       ${reset}- generate info package from source"
	echo -e "${pink}  -Sy, --update,        update         ${reset}- update list packages in repository online. Need Internet"
	echo -e "${pink}  -S,  --install,       install        ${reset}- install packages"
	echo -e "${pink}  -Si, --install,       install        ${reset}- install packages"
	echo -e "${pink}  -m, --meta,           meta           ${reset}- install meta packages"
	echo -e "${pink}  -r, --remove,         remove         ${reset}- remove packages"
	echo -e "${pink}  -Sc, --clean,         clean          ${reset}- erase downloaded packages files"
	echo -e "${pink}  -Ss, --search,        search         ${reset}- search for packages"
	echo -e "${pink}  -L, --list,           list           ${reset}- list avaiable packages based on package names"
	echo -e "${pink}  -La,--list-avaiable,  list-avaiable  ${reset}- list avaiable packages based on package names"
	echo -e "${pink}  -Lc,--list-cache,     list-cache     ${reset}- list downloaded packages in cache"
	echo -e "${pink}  -Li,--list-installed, list-installed ${reset}- list installed packages"
	echo -e "${pink}  -Lr,--list-removed,   list-removed   ${reset}- list packages removed by $0"
	echo -e "${pink}  -Pi,--in-cache,       in-cache       ${reset}- list packages in-cache"
	echo -e "${pink}  -Po,--out-cache,      out-cache      ${reset}- list packages out-cache"
	echo -e "${pink}  -w, --show,           show           ${reset}- show package details"
	echo -e "${pink}  -Sw, --download,      download       ${reset}- only download the binary package into cache directory"
	echo -e "${pink}  -R, --reinstall,      reinstall      ${reset}- reinstal packages"
	echo -e "${pink}  -Su, --upgrade,       upgrade        ${reset}- upgrade packages"
	echo -e "${pink}  -v, --version,        version        ${reset}- output version information and exit"
	echo
	echo -e "${cyan}ex:"
	echo -e "${yellow}  fetch update self - Update self fetch via internet"
	echo -e "  fetch create [packname-version-build]"
	echo -e "  fetch -Sy || fetch update"
	echo -e "  fetch -S <package> [...] [-y] [-f] [--nodeps] || fetch install <package> [...] [-y] [-f] [--nodeps]"
	echo -e "  fetch remove <package> [...] [-y] [-f]"
	echo -e "  fetch <package> [...] [-y] [-f]"
	echo -e "  fetch search <package> [...] [-y] [-f]"
	echo -e "  fetch list [<package>] [<...>]"
	echo -e "  fetch download [<package>] [...] [ALL] [-y] [-f]"
	echo -e "  fetch --meta [xorg] [-y] [-f]"
	echo -e "  fetch -a <package> [...] [-y] [-f] [-ctime=<n>]"
	echo -e "  fetch -a -ctime=<n>"
	exit

}

function init()
{
	local param=$@
	local s

	[[ $(toupper "${1}") = "-Y" ]] && { LAUTO=$true; shift; }
	[[ $(toupper "${1}") = "-F" ]] && { LFORCE=$true; shift; }
	[[ $(toupper "${1}") = "-Y" ]] && { LAUTO=$true; shift; }
	[[ $(toupper "${1}") = "-F" ]] && { LFORCE=$true; shift; }
	param="$@"
	[[ $LAUTO  ]] && param+=" -Y"
	[[ $LFORCE ]] && param+=" -F"

	case "${1}" in
		-Sl|--local|local)  							shift;sh_initinstallpkg "$@";;
		-Sa|-a|--alienpkg|alienpkg)	  		   shift;sh_alienpkg_main "$@";;
		-Sy|--update|update)							shift;sh_update "${param}";;
		-Sg|-g|--generate|generate)				sh_generatepkg "${param}";;
		-c|--create|create)					    	sh_createpkg "${param}";;
		-m|--meta|meta)	                     shift;sh_meta "${param}";;
		-Ss|-ss|-SS|-sS|--search|search)	     	shift;sh_search "$@";;
		-S|-s|-Si|-i|--install|install)			shift;sh_install "$@";;
		-r|--remove|remove) 							shift;sh_remove "${param}";;
		-R|--reinstall|reinstall) 					shift;sh_search "${param}";;
		-Sw|--download|download) 					shift;sh_download "${param}";;
		-L|-l|--list|list)    	 					shift;sh_list "$@";;
		-La|--list-avaiable|list-avaiable) 		shift;sh_list "$@";;
		-Lc|--list-cache|list-cache) 	        	shift;sh_FilesInCache "${param}";;
		-Lr|--list-removed|list-removed)			sh_removed $2 $3;;
		-Li|--list-installed|list-installed)	shift;sh_listinstalled "${@}";;
		-Pi|--in-cache|in-cache)	            shift;sh_FilesInCache "${param}";;
		-Po|--out-cache|out-cache)	            shift;sh_pkgoutcache "${param}";;
		-Sc|--clean|clean)  							sh_clean $2;;
		-w|--show|show) 								shift;sh_show "${param}";;
		-Su|--upgrade|upgrade)						sh_upgrade ${param};;
		-v|--version|version) 						exit;;
		*) 												sh_search "${param}";;
	esac
}


function conf()
{
    read -p "$1 [Y/n]"
    [[ ${REPLY^} == "" ]] && return $true
    [[ ${REPLY^} == N ]] && return $false || return $true
}


function confok()
{
    read -p "$1 [Y/n]"
    [[ ${REPLY^} == "" ]] && return $true
    [[ ${REPLY^} == N ]] && return $false || return $true
}


function confno()
{
    read -p "$1 [N/y]"
    [[ ${REPLY^} == "" ]] && return $false
    [[ ${REPLY^} == N  ]] && return $false || return $true
}


function sh_clean()
{
	local param=$@
	local lRetval=$false
	local nfiles=0

	sh_checkparametros ${param}
	if !(( $LAUTO )); then
		echo -e "Pacotes a serem mantidos:"
      echo -e "      Todos os pacotes instalados localmente"
		echo
		echo -e "Cache directory: $VARCACHE_ARCHIVES"
		conf "${blue}:: ${reset}Do you want to remove all packages from the cache?"
		LAUTO=$?
	fi

	if (( $LAUTO )); then
		log_info_msg "Deleting downloaded package files"
		[[ -d $VARCACHE_ARCHIVES ]] || mkdir -p $VARCACHE_ARCHIVES
		nfiles=$(ls -la $VARCACHE_ARCHIVES/|grep -e "^-"|wc -l)
		rm -f $VARCACHE_ARCHIVES/*
		evaluate_retval
		lRetval=$true
		> $VARCACHE_SEARCH/packages-in-cache
		log_success_msg2 "${yellow}($nfiles) ${cyan}files deleted"
	fi
	sh_cdroot
	return $lRetval
}


function sh_checkdir()
{
	log_wait_msg "Checking job directories"
	if [ $# -lt 1 ]; then
		log_info_msg "$VARCACHE_ARCHIVES" ; [[ -d $VARCACHE_ARCHIVES  ]] && evaluate_retval || { mkdir -p $VARCACHE_ARCHIVES  >/dev/null 2>&1; evaluate_retval; }
		log_info_msg "$VARCACHE_REMOVED"  ; [[ -d $VARCACHE_REMOVED   ]] && evaluate_retval || { mkdir -p $VARCACHE_REMOVED   >/dev/null 2>&1; evaluate_retval; }
		log_info_msg "$VARCACHE_INSTALLED"; [[ -d $VARCACHE_INSTALLED ]] && evaluate_retval || { mkdir -p $VARCACHE_INSTALLED >/dev/null 2>&1; evaluate_retval; }
		log_info_msg "$VARCACHE_SEARCH"   ; [[ -d $VARCACHE_SEARCH    ]] && evaluate_retval || { mkdir -p $VARCACHE_SEARCH    >/dev/null 2>&1; evaluate_retval; }
		log_info_msg "$VARLIB_LIST"       ; [[ -d $VARLIB_LIST        ]] && evaluate_retval || { mkdir -p $VARLIB_LIST        >/dev/null 2>&1; evaluate_retval; }
		log_info_msg "$VARLIB_DESC"       ; [[ -d $VARLIB_DESC        ]] && evaluate_retval || { mkdir -p $VARLIB_DESC        >/dev/null 2>&1; evaluate_retval; }
		log_info_msg "$VARLIB_REMO"       ; [[ -d $VARLIB_REMO        ]] && evaluate_retval || { mkdir -p $VARLIB_REMO        >/dev/null 2>&1; evaluate_retval; }
	else
		[[ -d $VARCACHE_ARCHIVES  ]] || mkdir -p $VARCACHE_ARCHIVES  >/dev/null 2>&1
		[[ -d $VARCACHE_REMOVED   ]] || mkdir -p $VARCACHE_REMOVED   >/dev/null 2>&1
		[[ -d $VARCACHE_INSTALLED ]] || mkdir -p $VARCACHE_INSTALLED >/dev/null 2>&1
		[[ -d $VARCACHE_SEARCH    ]] || mkdir -p $VARCACHE_SEARCH    >/dev/null 2>&1
		[[ -d $VARLIB_LIST        ]] || mkdir -p $VARLIB_LIST        >/dev/null 2>&1
		[[ -d $VARLIB_DESC        ]] || mkdir -p $VARLIB_DESC        >/dev/null 2>&1
		[[ -d $VARLIB_REMO        ]] || mkdir -p $VARLIB_REMO        >/dev/null 2>&1
	fi
	return $?
}


function sh_update()
{
	[[ $(toupper "${1}") = "SELF" ]] && { shift; sh_selfupdate "$@"; return $?;}

	#internet?
	sh_checknet; [[ $? = $false ]] || { return 1;}
	sh_checkdir "OFF"

	cd $VARCACHE_SEARCH/

	log_info_msg "Cleaning up $VARCACHE_SEARCH/"
	> $VARCACHE_SEARCH/folders
	> $VARCACHE_SEARCH/folders_packages
	> $VARCACHE_SEARCH/packages
	> $VARCACHE_SEARCH/packages-split
	> $VARCACHE_SEARCH/folders_metapackages
	> $VARCACHE_SEARCH/metapackages
	evaluate_retval

	log_info_msg "Updating Folders from ${SITE}"
	if !(( $GITSITE )); then
		#sites com gninx/apache/etc
		#curl --insecure --silent --url "${SITE}/packages/"| grep "/</a" | grep '[a-z]' | sed 's/<[^>]*>//g'| cut -d/ -f1|sed 's/^[ \t]*//;s/[ \t]*$//'|sed 's/Index of//g' > ${VARCACHE_SEARCH}/folders
		#curl --insecure --silent --url "${SITE}/packages/"|sed 's/<[^>]*>//g'| cut -d/ -f1|sed 's/^[ \t]*//;s/[ \t]*$//'|sed 's/Index of//g' > ${VARCACHE_SEARCH}/folders
		curl --insecure --silent --url "${SITE}/packages/"|grep href|sed 's/[*<>]//g'|sed 's/[*=/"]/:/g'|cut -d: -sf3 > ${VARCACHE_SEARCH}/folders
	else
		#repositorio github
		curl --insecure --silent --url "${SITE}/packages/"|grep /packages/ | sed 's/<[^>]*>//g' | sed 's/ //g' > ${VARCACHE_SEARCH}/folders
	fi

#	FoldersInRepo='arch base dev extra games lib meta net sec theme x xapp'
#	echo "${FoldersInRepo[@]}" > ${VARCACHE_SEARCH}/folders

	evaluate_retval
	log_wait_msg "${pink}Updating packages lists from ${SITE}...${reset}"
	FoldersInRepo=$(cat $VARCACHE_SEARCH/folders)

#	> folders_packages
#	> packages
#	> folders_metapackages
#	> metapackages
	spinner & pid=$!
	local Folders
	for Folders in ${FoldersInRepo}; do
		if !(( $GITSITE )); then
			#site normal
			PackagesInFolders=$(curl -k --silent --url "${SITE}/packages/${Folders}/"|sed 's/^.*href="//' | sed 's/".*$//' | grep ".${PRG}$" | awk '{print $1}')
			MetaPkgInFolders=$(curl -k --silent --url "${SITE}/packages/${Folders}/"|sed 's/^.*href="//' | sed 's/".*$//' | grep ".meta$" | awk '{print $1}')
		else
			#repositorio github
			PackagesInFolders=$(curl --insecure --silent --url "${SITE}/packages/${Folders}/"|sed 's/^.*href="//' | sed 's/".*$//' | sed 's/\// /g' | grep ".${PRG}$"| awk '{print $NF}')
			MetaPkgInFolders=$(curl --insecure --silent --url "${SITE}/packages/${Folders}/" |sed 's/^.*href="//' | sed 's/".*$//' | sed 's/\// /g' | grep ".meta$" | awk '{print $NF}')
		fi

		local count=0
		for pkgInFolder in $PackagesInFolders; do
			sh_splitpkg ${pkgInFolder}
			echo "${Folders}/${pkgInFolder}" >> folders_packages
			sed -i '/'${pkgInFolder}'/d' $VARCACHE_SEARCH/packages
			sed -i '/'${pkgInFolder}'/d' $VARCACHE_SEARCH/packages-split
			echo "${pkgInFolder}"            >> packages
			echo "${aPKGSPLIT[$PKG_BASE]}:${aPKGSPLIT[$PKG_VERSION]}:${aPKGSPLIT[$PKG_BUILD]}:${aPKGSPLIT[$PKG_FULLNAME]}:${Folders}/${pkgInFolder}" >> $VARCACHE_SEARCH/packages-split
			((count++))
		done
		for MetaInFolder in $MetaPkgInFolders; do
			echo "${Folders}/${MetaInFolder}" >> folders_metapackages
			echo "${MetaInFolder}"            >> metapackages
			((count++))
		done

		cstrvalue=$(strzero ${count} 5)
#		[[ ${count} =  0 ]] || log_success_msg2 "  Updating... (${blue}${cstrvalue}${reset}) packages in ${Folders}"
#		[[ ${count} != 0 ]] || log_failure_msg2 "  Updating... (${blue}${cstrvalue}${reset}) packages in ${Folders}"
		log_success_msg2 "  Updating... (${blue}${cstrvalue}${reset}) packages in ${Folders}"
	done
	{ kill $pid; wait $pid 2>/dev/null; echo ;}
	sh_recreatefilepackagesinstalled
	echo
	local nfilesInReposit=$(cat $VARCACHE_SEARCH/folders_packages | wc -l)
	local nfilesInstalled=$(cat $VARCACHE_SEARCH/packages-installed | wc -l)
	local nfilesRemoved=0
	[[ -e $VARCACHE_SEARCH/packages-removed ]] && nfilesRemoved=$(cat $VARCACHE_SEARCH/packages-removed | wc -l)

	echo -e "${cyan}All list packages updated!${reset}"
#	maxcol; replicate "=" $?
	echo -e "${blue}($nfilesInReposit) packages in repository${reset}"
	echo -e "${green}($nfilesInstalled) packages installed${reset}"
	echo -e "${red}($nfilesRemoved) packages removed by $0${reset}"
#	maxcol; replicate "=" $?
	echo -e ${reset}

#	conf "List out-of-cache packages?"
#	[[ $? = $true ]] && sh_pkgoutcache

	echo -e "${reset}Use: # $0 --help for helping${reset}"
	echo
	sh_cdroot
	exit
}


function sh_FilesInCache()
{
	local nfilesincache=0
	local index=1

	pushd $VARCACHE_ARCHIVES/ &>/dev/null
	aCache=($(echo *.${PRG}))
	[ ${aCache[0]} = "*.${PRG}" ] && aCache=()
	[[ -e $VARCACHE_SEARCH/packages-in-cache ]] || rm -f $VARCACHE_SEARCH/packages-in-cache
	> $VARCACHE_SEARCH/packages-in-cache
	for item in ${aCache[*]}; do
    	echo $item >> $VARCACHE_SEARCH/packages-in-cache
	done
	popd  &>/dev/null
	nfilesincache=${#aCache[*]}

    if [[ "$1" != "OFF" ]]; then
        [ $nfilesincache <> 0 ] || maxcol; replicate "=" $?
        index=1
        for y in ${aCache[*]}
        do
            log_success_msg2 "IN CACHE: [$index]${orange}$y${reset}"
            ((index++))
        done
        [ $nfilesincache <> 0 ] || maxcol; replicate "=" $?
        echo -e "${yellow}($nfilesincache)  ${cyan}packages in cache"
    fi
	return $nfilesincache
}


function sh_pkgoutcache()
{
	log_wait_msg "Ok, let's do it..."
	log_info_msg "Wait, doing some calculations..."

	sh_FilesInCache "OFF"
	local nfilesincache=${?}
	evaluate_retval

	local aPkgOut=()
	local aRepository=$(_CAT $VARCACHE_SEARCH/packages)
	local x
	local y
	local index=0
	local lfind=$false

	for x in ${aRepository[*]};do
		lfind=$false
		for y in ${aCache[*]};do
			if [ $x = $y ]; then
				lfind=$true
				break
			fi
		done
		if [ $lfind = $false ]; then
			aPkgOut[$index]=$x
			((index++))
		fi
    done
	local nfilesoutcache=${#aPkgOut[*]}
	[ $nfilesoutcache <> 0 ] || maxcol; replicate "=" $?
    index=1
	for y in ${aPkgOut[*]}
	do
		log_failure_msg2 "NOT IN CACHE: [$index]${orange}$y${reset}"
		((index++))
	done
	[ $nfilesoutcache <> 0 ] || maxcol; replicate "=" $?
	echo -e "${yellow}($nfilesincache)  ${cyan}packages in cache"
	echo -e "${yellow}($nfilesoutcache) ${cyan}packages in repository e out cache"
	return 0
}


function sh_show()
{
	local param=$@
	local LFORCE=$false
	local pkgCheckNumber=0

	log_wait_msg "Reading package lists..."
	sh_checkdir "OFF"

	for s in ${param[@]}; do
#		[[ $(toupper "${s}") = "-Y" ]]  && { LAUTO=$true;  param[$count]=;}
#		[[ $(toupper "${s}") = "-F" ]]  && { LFORCE=$true; param[$count]=;}
#		[[ $(toupper "${s}") = "OFF" ]] && { LLIST=$false; param[$count]=;}
#		((count++))
		[[ $(toupper "${s}") = "-Y" ]]  && LAUTO=$true
		[[ $(toupper "${s}") = "-F" ]]  && LFORCE=$true
		[[ $(toupper "${s}") = "OFF" ]] && LLIST=$false
	done

	sh_listinstalled ${param} "OFF" "EXACT"

	local ntotal_pkg_installed=${public_ntotal_pkg_installed}
	local ntotal_pkg_listed=${public_ntotal_pkg_listed}

	log_wait_msg "Listing..."
	if [[ $pkginstalled != " " ]]; then
		for i in $pkginstalled; do
			log_success_msg2 "${green}FOUND ${reset} ${orange}${i}${reset}"
			((pkgCheckNumber++))
			log_success_msg2 "($pkgCheckNumber) file(s) found."
			local cfile=${i}
			#local cbase=$(echo $cfile | cut -d/ -f1)
    		#local cpacote=$(echo $cfile | cut -d/ -f2)".desc"
			sh_splitpkg ${i}
			local cBase=${aPKGSPLIT[$PKG_BASE]}
			local cBaseVersion=${aPKGSPLIT[$PKG_BASE_VERSION]}
			local cpacote=${aPKGSPLIT[$PKG_BASE_VERSION]}.desc
			local cVersion=${aPKGSPLIT[$PKG_VERSION]}
			local cBuild=${aPKGSPLIT[$PKG_BUILD]}

    		cd $VARCACHE_ARCHIVES/
    		[[ $LFORCE = $true ]] && sh_wgetdesc || test -e $VARCACHE_ARCHIVES/$cpacote || sh_wgetdesc
 			evaluate_retval
    		local error_value="${?}"

    		if [ ${error_value} = 0 ]; then
    			log_wait_msg "${blue}Dumping... $cpacote${reset}"
    			echo -e "${cyan}"
    			_CAT $VARLIB_DESC/$cpacote
    			echo -e "${reset}"
    		else
    			log_failure_msg2 "${red}ERROR Downloading... $cpacote${reset}"
    		fi

		done
	else
		log_failure_msg2 "${red}$param NOT FOUND${reset} ${orange}$i${reset}"
		log_failure_msg2 "($pkgCheckNumber) file(s) found."
	fi
	sh_cdroot
}


function _PRE_REMOVE()
{
	(
	local packname="$1"
	local ntam=${#packname}
	local pkgsearch="${packname:0:$((ntam-2))}"
	local re="\b${pkgsearch}\b"
	local inc=0
	local count_occurrences=0
	local search_pack

	pushd $VARLIB_DESC 1>/dev/null
#	local alldesc="$(echo *.desc | grep $pkgsearch)"
	local alldesc=$(echo $pkgsearch*)

	for search_pack in $alldesc; do
		if [[ "$search_pack" =~ ^${re}.* ]]; then
			for q in *; do
				if [[ "$q" =~ ^${re}.* ]]; then
					((count_occurrences++))
				fi
			done
			source $VARLIB_DESC/${search_pack}
#			local name_version_build="${pkgname}-${version}-${build}"
			local name_version_build="${packname}"
			AUTO_YES=$true
			pushd "${VARLIB_LIST}" 1>/dev/null
			search_pack="${search_pack/%.desc/.list}" # se terminar com .desc substitua por .list
			[[ -e "${search_pack}" ]] && { _REMOVE_NOW "$name_version_build"; return 0 ;} || { log_failure_msg2 "ERROR: FILE NOT FOUND ${VARLIB_LIST}/${search_pack}"; return 1;}
			continue
		else
			((inc++))
		fi
	done

	[[ "$inc" -gt '0' ]] && { log_failure_msg2 "NOT FOUND ${packname}"; return 1 ;}
	)
	_SUBSHELL_STATUS
}


function sh_removepkg()
{
	shift
	while [[ -n "$1" ]]; do
		_PRE_REMOVE "$1" || return 1
		retval=${?}
		_pkginstalled=($(echo $VARCACHE_INSTALLED/${1}*| sed 's|/| |g'|awk '{print $5}'|sed 's/.'${PRG}'//g'))
		[[ $retval = 0 ]] && _pkg=($(echo $VARCACHE_INSTALLED/${1}*| sed 's|/| |g'|awk '{print $5}'))
		[[ $retval = 0 ]] && rm -f $VARCACHE_INSTALLED/${_pkg}
		[[ $retval = 0 ]] && > $VARCACHE_REMOVED/${_pkg}
		[[ $retval = 0 ]] && sed -i  '/'${_pkginstalled}'/d' $VARCACHE_SEARCH/packages-installed
		[[ $retval = 0 ]] && sed -i  '/'${_pkginstalled}'/d' $VARCACHE_SEARCH/packages-installed-split
		shift
	done
	return 0
}


function sh_doremove()
{
	local param=$@

	log_wait_msg "Wait, Removing package ${orange}${i}"
#	ERROR=$(sh_removepkg -r $1 2>&1)
	sh_removepkg -r $1
	local error_value="${?}"
	if [ ${error_value} != 0 ]; then
		log_failure_msg2 "$ERROR"
	else
		if (( $LLIST )); then
			log_success_msg2 "${green}${2}${reset} Done. Removal of the package successfully completed"
		fi
	fi
	return $error_value
}


function sh_remove()
{
	LAUTO=$false
	local param=$@

	sh_listinstalled ${param}
	local lExist=$?
	[ $lExist -eq 0 ] && return 1

	sh_checkparametros ${param}

	if [[ $pkginstalled != " " ]]; then
		if !(( $LAUTO )); then
			echo
			confno "${blue}::${reset} Remove package(s)?"
			LAUTO=$?
		fi

		if (( $LAUTO )); then
			[[ -d $VARCACHE_ARCHIVES ]] || mkdir -p $VARCACHE_ARCHIVES
			cd $VARCACHE_ARCHIVES/

			for i in $pkginstalled; do
				declare -g ee=$i
				local cfile=$i
				local cbase=$(echo $cfile | cut -d/ -f1)
				local cpacote=$(echo $cfile | cut -d/ -f2 | sed 's/.'${PRG}'//g')
				sh_doremove $cpacote $i
			done
		fi
	fi
	sh_cdroot
	return 0
}


function sh_download()
{
	[[ $(toupper "${1}") = "ALL" ]] && LALL=$true   || LALL=$false
	[[ $(toupper "${2}") = "-F"  ]] && LFORCE=$true || LFORCE=$false

	sh_list $@ "ON"
	local nFilesDownloaded=0
	local nTotalFiles=$pkgCheckNumber
	local cspace=$(printf "%20s" ' ')

	# Check package exist.
	if [[ $pkg != "" ]]; then
		if [ $# -ge 1 ]; then
			if [ ${LALL} = $true ]; then
				pkgCheckNumber='1'
			fi
		fi

#		sh_checknet; [[ $? = $false ]] || { return 1;}
#		spinner & pid=$!
		for i in $pkg; do
#			local cfile=$i
#			local cbase=$(echo $cfile | cut -d/ -f1)
#			local cpacote=$(echo $cfile | cut -d/ -f2)

			sh_splitpkg ${i}
			local cfullname=${aPKGSPLIT[$PKG_FULLNAME]}
			local cbase=${aPKGSPLIT[$PKG_BASE]}
			local cBaseVersion=${aPKGSPLIT[$PKG_BASE_VERSION]}
			local cpacote=${aPKGSPLIT[$PKG_BASE_VERSION]}
			local cVersion=${aPKGSPLIT[$PKG_VERSION]}
			local cBuild=${aPKGSPLIT[$PKG_BUILD]}

			## Download package.
			((nFilesDownloaded++))
			cd $VARCACHE_ARCHIVES/
			log_wait_msg "File ${red}#${nFilesDownloaded} of ${nTotalFiles}${reset}|Checking package ${orange}${cfullname} ${cspace}"
    		[[ $LFORCE = $true ]] && sh_wgetfull || test -e $VARCACHE_ARCHIVES/$cfullname || sh_wgetfull
		done
#		{ kill $pid; wait $pid 2>/dev/null; echo ;}
#		echo ""
		log_success_msg2 "${cyan}($nFilesDownloaded) packages(s) downloaded."
	else
		echo
		echo "Choose one package for download or install."
	fi
	sh_cdroot
}


function DOT()
{
	printf "${blue}:: ${reset}"
	return
}

function sh_adel()
{
	#removendo duplicados e ordenando
	local arr=${1}
	local item

	> /tmp/.array >/dev/null 2>&1
	for item in ${arr[*]}
	do
		echo $item >> /tmp/.array    #imprime o conteudo da matriz
	done
	unset arr
	unset deps
	deps=$(uniq --ignore-case <<< $(sort /tmp/.array))
	[[ -e /tmp/.array ]] && rm /tmp/.array >/dev/null 2>&1
	return $?
}

function sh_getdeps()
{
	local ncontadep=0
	local ncontapkgdep=0
	local	arr=()
	local pkgNumber=0
   local cfullfilename
   local x
   local LDEPS=${1}
	deps=

	echo "$(DOT)${cyan}resolvendo dependencias..."
  	GETDEPS=

   for i in $pkgforinstall; do
      sh_splitpkg "${i}"
      cbase=${aPKGSPLIT[PKG_BASE]}
      cfullfilename=${aPKGSPLIT[PKG_FULLNAME]}
      test -e $VARCACHE_ARCHIVES/$cfullfilename.desc || sh_wgetdesc
      source $VARCACHE_ARCHIVES/$cfullfilename.desc
   	deps="$deps ${cbase}"
      if (( $LDEPS )); then
      	deps="$deps ${dep[*]}"
      	deps="$deps $(cat $VARCACHE_ARCHIVES/${cfullfilename}.desc | grep ^depend | awk -F"'" '{print $2}')"
      fi
   done

  	sh_adel "$deps"
  	arr=(${deps[*]})
  	ncontapkgdep=${#arr[*]}
   printf "%12sPackage(${ncontapkgdep})%34sversion%8sfullname\n"

  	for i in ${deps[*]}
  	do
  		((ncontadep++))
  		pkgdep=$(cat $VARCACHE_SEARCH/packages-split | grep ^${i}: | awk -F":" '{print $5}')
  		if [[ $pkgdep = "" ]]; then
  			printf "${red}%s(%04d) ${orange}%-40s ${reset}%-40s\n" "     " "$ncontadep" "${i}" "WARNING! Dependencia nao localizada na base de dados. ${reset}Use: # ${APP} -Sy to update with the repository${reset}"#
  		else
  			sh_splitpkg $pkgdep
  			printf "${green}%s(%04d) ${orange}%-43s ${reset}%-15s%s\n" "     " "$ncontadep" "${aPKGSPLIT[$PKG_BASE]}" "${aPKGSPLIT[$PKG_VERSION]}" "${aPKGSPLIT[$PKG_FOLDER_DIR]}/${aPKGSPLIT[$PKG_FULLNAME]}"
  			GETDEPS="$GETDEPS $(echo $pkgdep)"
  		fi
  	done
  	pkgforinstall=$GETDEPS
   return $?
}


function sh_wgetdesc()
{
   local cOldDir=$PWD
	local cfullfilename=$1

	local cRaw
	if !(( $GITSITE )); then
		#site normal
		cRaw=$SITE
	else
		#github
		cRaw=$RAW
	fi
	cd $VARCACHE_ARCHIVES/
#	log_info_msg "${cyan}Fetching file ${cRaw}/packages/${orange}${i}.desc"   ; curl -s -k -O "${cRaw}/packages/${i}.desc"   ; evaluate_retval
	curl -s -k -O "${cRaw}/packages/${i}.desc"
	cd $cOldDir
	return $?
}


function sh_wgetfull()
{
	local cfullfilename=$1
	local cRaw
	if !(( $GITSITE )); then
		#site normal
		cRaw=$SITE
	else
		#github
		cRaw=$RAW
	fi
#	sh_checknet; [[ $? = $false ]] || { return 1;}
	log_info_msg "${cyan}Fetching package ${cRaw}/packages/${orange}${i}"        ; curl -s -k -O "${cRaw}/packages/$i"        ; evaluate_retval
#	log_info_msg "${cyan}Fetching file    ${cRaw}/packages/${orange}${i}.desc"   ; curl -s -k -O "${cRaw}/packages/$i.desc"   ; evaluate_retval
#	log_info_msg "${cyan}Fetching file    ${cRaw}/packages/${orange}${i}.sha256" ; curl -s -k -O "${cRaw}/packages/$i.sha256" ; evaluate_retval
#	log_info_msg "${cyan}Fetching filee   ${cRaw}/packages/${orange}${i}.sig"    ; curl -s -k -O "${cRaw}/packages/$i.sig"    ; evaluate_retval
	return $?
}


function sh_wgetpartial()
{
	local cfullfilename=$1
	local cRaw
	if !(( $GITSITE )); then
		#site normal
		cRaw=$SITE
	else
		#github
		cRaw=$RAW
	fi
#	sh_checknet; [[ $? = $false ]] || { return 1;}
	test -e $VARCACHE_ARCHIVES/$cpacote 			|| { log_info_msg "${cyan}Fetching package ${cRaw}/packages/${orange}${i}"     ; curl -s -k -O "${cRaw}/packages/$i"        ; evaluate_retval; }
	test -e $VARCACHE_ARCHIVES/$cpacote.desc		||	{ log_info_msg "${cyan}Fetching file ${cRaw}/packages/${orange}${i}.desc"   ; curl -s -k -O "${cRaw}/packages/$i.desc"   ; evaluate_retval; }
#	test -e $VARCACHE_ARCHIVES/$cpacote.sha256	||	{ log_info_msg "${cyan}Fetching file ${cRaw}/packages/${orange}${i}.sha256" ; curl -s -k -O "${cRaw}/packages/$i.sha256" ; evaluate_retval; }
#	test -e $VARCACHE_ARCHIVES/$cpacote.sig 		||	{ log_info_msg "${cyan}Fetching file ${cRaw}/packages/${orange}${i}.sig"    ; curl -s -k -O "${cRaw}/packages/$i.sig"    ; evaluate_retval; }
	return $?
}


function sh_checksha256sum()
{
	log_info_msg "Checking sha256sum..."
	ERROR=$(sha256sum -c ${cpacote}.sha256 2>&1>/dev/null)
	evaluate_retval
	return $?
}

function sh_splitbase()
{
	local file=${1}
	local pkg_folder_dir=""
	local pkg_fullname
	local pkg_arch
	local pkg_base
	local pkg_base_version
	local pkg_version
	local pkg_build

	aPKGSPLIT=()
	pkg_fullname=$(echo ${file##*/})    						#remove diretorio deixando somente nome do pacote
	pkg_arch=$(echo ${pkg_fullname%%.${PRG}})   				#remove extensao pacote (chi.zst/mz)
	pkg_base=$(echo ${pkg_arch%.*})         					# https://elmord.org/blog/?entry=20121227-manipulando-strings-bash
	pkg_base=$(echo ${pkg_base%-*})   				  			# https://elmord.org/blog/?entry=20121227-manipulando-strings-bash

	pkg_base_version=$(echo ${pkg_arch%-any*})      		# https://elmord.org/blog/?entry=20121227-manipulando-strings-bash
	pkg_base_version=$(echo ${pkg_base_version%-x86_64*})	# https://elmord.org/blog/?entry=20121227-manipulando-strings-bash
	pkg_version=$(echo ${pkg_base_version#*-})				# https://elmord.org/blog/?entry=20121227-manipulando-strings-bash
	pkg_version=$(echo ${pkg_version#*-})						# https://elmord.org/blog/?entry=20121227-manipulando-strings-bash
	pkg_build=$(echo ${pkg_version#*-})							# https://elmord.org/blog/?entry=20121227-manipulando-strings-bash

	aPKGSPLIT=($pkg_folder_dir $pkg_fullname $pkg_arch $pkg_base $pkg_base_version $pkg_version $pkg_build)
	return $?
}

function sh_oldsplitpkg()
{
	local file=${1}
	local pkg_folder_dir
	local pkg_fullname
	local pkg_arch
	local pkg_base
	local pkg_base_version
	local pkg_version
	local pkg_build

	aPKGSPLIT=()
	pkg_folder_dir=$(echo ${file%/*})							#remove arquivo deixando somente o diretorio/repo
	pkg_fullname=$(echo ${file##*/})    						#remove diretorio deixando somente nome do pacote
	pkg_arch=$(echo ${pkg_fullname%%.${PRG}})   				#remove extensao pacote (chi.zst/mz)
	pkg_base=$(echo ${pkg_arch%.*})         					# https://elmord.org/blog/?entry=20121227-manipulando-strings-bash
	pkg_base=$(echo ${pkg_base%-*})   				  			# https://elmord.org/blog/?entry=20121227-manipulando-strings-bash

	pkg_base_version=$(echo ${pkg_arch%-any*})      		# https://elmord.org/blog/?entry=20121227-manipulando-strings-bash
	pkg_base_version=$(echo ${pkg_base_version%-x86_64*})	# https://elmord.org/blog/?entry=20121227-manipulando-strings-bash
	pkg_version=$(echo ${pkg_base_version#*-})				# https://elmord.org/blog/?entry=20121227-manipulando-strings-bash
	pkg_version=$(echo ${pkg_version#*-})						# https://elmord.org/blog/?entry=20121227-manipulando-strings-bash
	pkg_build=$(echo ${pkg_version#*-})							# https://elmord.org/blog/?entry=20121227-manipulando-strings-bash

	pkg_arch="${file%.*}"
	pkg_base_version="${file%-*}"
	pkg_build="${pkg_base_version##*-}"
	pkg_version="${file%-*}"
	pkg_version="${pkg_version%-*}"
	pkg_base="${pkg_version%-*}"
	pkg_version="${pkg_version##*-}-$pkg_build"

	aPKGSPLIT=($pkg_folder_dir $pkg_fullname $pkg_arch $pkg_base $pkg_base_version $pkg_version $pkg_build)
	aPKGLIST=${aPKGSPLIT[*]}
#	arr=(${aPKGSPLIT[*]})
#	info "${arr[0]}\n${arr[1]}\n${arr[2]}\n${arr[3]}\n${arr[4]}\n${arr[5]}\n${arr[6]}\n${arr[7]}"
	return $?
}


function sh_splitpkg()
{
	local file=${1}
	local pkg_folder_dir
	local pkg_fullname
	local pkg_arch
	local pkg_base
	local pkg_base_version
	local pkg_version
	local pkg_build
	local pkg_str
	local nconta=0
	local char="-"
	local var
	local ra
	local re

	aPKGSPLIT=()
	pkg_folder_dir=$(echo ${file%/*})							#remove arquivo deixando somente o diretorio/repo
	pkg_fullname=$(echo ${file##*/})    						#remove diretorio deixando somente nome do pacote
#	pkg_arch=$(echo ${pkg_fullname%.${PRG}*})  				#remove extensao pacote (chi.zst/mz)
#	pkg_str=$(echo ${pkg_arch%-any*})      					# https://elmord.org/blog/?entry=20121227-manipulando-strings-bash
#	pkg_str=$(echo ${pkg_str%-x86_64*})      					# https://elmord.org/blog/?entry=20121227-manipulando-strings-bash

	pkg_arch=$(echo ${pkg_fullname%-any.${PRG}*}) 			#remove extensao pacote (chi.zst/mz)
	pkg_arch=$(echo ${pkg_arch%-x86_64.${PRG}*}) 			#remove extensao pacote (chi.zst/mz)
	pkg_arch=$(echo ${pkg_arch%.${PRG}*})  				  #remove extensao pacote (chi.zst/mz)
	pkg_str=$pkg_arch

	#debug
	#info "file: $file\npkg_folder_dir: $pkg_folder_dir\npkg_fullname: $pkg_fullname\npkg_arch: $pkg_arch\npkg_str: $pkg_str"

	IFS='-' 									# hyphen (-) is set as delimiter
	read -ra ADDR <<< "$pkg_str"		# str is read into an array as tokens separated by IFS
	for var in "${ADDR[@]}"; do 		# access each element of array
		re='[a-zA-Z]'
		if [[ "$var" =~ $re ]]; then
			pkg_base="$pkg_base${var}$char"
		else
			((nconta++))
			[[ $nconta -eq 1 ]] && pkg_version=$var || pkg_build=$var
			#debug
			#info "pkg_version: $pkg_version\npkg_build: $pkg_build"
		fi
	done
 	IFS=$SAVEIFS # reset to default value after usage
	pkg_base=${pkg_base%-*}
	pkg_version="${pkg_version}-${pkg_build}"
	pkg_base_version="${pkg_base}-${pkg_version}"
	[[ $pkg_folder = "" ]] && pkg_folder=$pkg_fullname

	#debug
#	info " pkg_folder      : $pkg_folder\n" \
#	 	  "pkg_fullname    : $pkg_fullname\n" \
#	 	  "pkg_arch        : $pkg_arch\n" \
#	 	  "pkg_base        : $pkg_base\n" \
#		  "pkg_base_version: $pkg_base_version\n" \
#		  "pkg_version     : $pkg_version\n" \
#		  "pkg_build       : $pkg_build"

	aPKGSPLIT=($pkg_folder_dir $pkg_fullname $pkg_arch $pkg_base $pkg_base_version $pkg_version $pkg_build)
	aPKGLIST=${aPKGSPLIT[*]}
	arr=(${aPKGSPLIT[*]})
#	echo -e "${arr[0]}\n${arr[1]}\n${arr[2]}\n${arr[3]}\n${arr[4]}\n${arr[5]}\n${arr[6]}\n${arr[7]}"
#	info "${arr[0]}\n${arr[1]}\n${arr[2]}\n${arr[3]}\n${arr[4]}\n${arr[5]}\n${arr[6]}\n${arr[7]}"
	return $?
}


function sh_installdownload()
{
		for i in $pkgforinstall; do
			sh_splitpkg ${i}
			local cfullfilename=${aPKGSPLIT[PKG_FULLNAME]}
			local cpacote=${aPKGSPLIT[PKG_FULLNAME]}
			local cpacotebase=${aPKGSPLIT[PKG_BASE]}
			test -e $VARCACHE_ARCHIVES/$cpacote || sh_wgetpartial
			local error_value="${?}"
			if [ ${error_value} -ne 0 ]; then
				log_failure_msg2 "ERROR: Downloading ${orange}${cfullfilename}"
				log_wait_msg "Restarting download ${orange}${cfullfilename}"
				sh_wgetfull
				local error_value="${?}"
				if [ ${error_value} -ne 0 ]; then
					log_failure_msg2 "ERROR: Fatal error downloading ${orange}${cfullfilename}. ${reset}Aborting..."
					exit 1
				fi
			fi
		done
}

function sh_installdoinstallpkg()
{
		for i in $pkgforinstall; do
			sh_splitpkg ${i}
			local cfullfilename=${aPKGSPLIT[PKG_FULLNAME]}
			local cpacote=${aPKGSPLIT[PKG_FULLNAME]}
			local cpacotebase=${aPKGSPLIT[PKG_BASE]}
			case $cpacotebase in
				gcc)	      log_failure_msg2 "Skipping package: $cpacotebase"; continue;;
				gcc-libs)   log_failure_msg2 "Skipping package: $cpacotebase"; continue;;
				glibc)	   log_failure_msg2 "Skipping package: $cpacotebase"; continue;;
				file)	      log_failure_msg2 "Skipping package: $cpacotebase"; continue;;
				flac)	      log_failure_msg2 "Skipping package: $cpacotebase"; continue;;
			esac
			cpacoteinstalled=$(grep ^$cpacoteSemExt ${VARCACHE_SEARCH}/packages-installed)
			[[ $cpacoteinstalled = $cpacoteSemExt ]] && LINSTALLED=$true

#			info "1-cpacoteSemExt   : $cpacoteSemExt\n2-cpacoteinstalled: $cpacoteinstalled"

			if (( $LINSTALLED )) && !(( $LFORCE )); then
				log_failure_msg2 "${orange}${cfullfilename} ${reset}Package is already installed. Use the -f option to force reinstallation."
				continue
			fi
			sh_installpkg -i ${cpacote}
			local error_value="${?}"
			if [ ${error_value} -ne 0 ]; then
				log_failure_msg2 "${red}ERROR:${reset} installing package: ${orange}${cpacote}${reset}"
			else
				log_success_msg2 "${green}${cpacote} ${reset}Done. package installation successfully."
			fi
		done
}

function sh_install()
{
	local param=$@
	#sh_checknet

	sh_listforinstall ${param} "ON" "EXACT"

	if [[ $pkgforinstall != " " ]]; then
		[[ -d $VARCACHE_ARCHIVES/ ]] || mkdir -p $VARCACHE_ARCHIVES/
		cd $VARCACHE_ARCHIVES/

		if !(( $LAUTO )); then
			read -p "${blue}:: ${reset}Continue installation? [Y/n]" LDOWNLOAD
			if [[ $(toupper "${LDOWNLOAD}") = "N" ]]; then
				return
			fi
		fi

		for i in $pkgforinstall; do
			sh_splitpkg ${i}
			local cfullfilename=${aPKGSPLIT[PKG_FULLNAME]}
			local cpacote=${aPKGSPLIT[PKG_FULLNAME]}
			local cpacotebase=${aPKGSPLIT[PKG_BASE]}
			local cpacoteSemExt=${aPKGSPLIT[PKG_BASE_VERSION]}
			local LINSTALLED=$false
			local cpacoteinstalled=

#			case $cpacotebase in
#				gcc)	      log_failure_msg2 "Skipping package: $cpacotebase"; continue;;
#				gcc-libs)   log_failure_msg2 "Skipping package: $cpacotebase"; continue;;
#				glibc)	   log_failure_msg2 "Skipping package: $cpacotebase"; continue;;
#				file)	      log_failure_msg2 "Skipping package: $cpacotebase"; continue;;
#				flac)	      log_failure_msg2 "Skipping package: $cpacotebase"; continue;;
#			esac

#			info "1-$cfullfilename\n2-$cbase\n3-$cpacote\n4-$cpacoteSemExt"

#			cpacoteinstalled=$(grep ^$cpacoteSemExt ${VARCACHE_SEARCH}/packages-installed)
#			[[ $cpacoteinstalled = $cpacoteSemExt ]] && LINSTALLED=$true

#			info "1-cpacoteSemExt   : $cpacoteSemExt\n2-cpacoteinstalled: $cpacoteinstalled"

#			if (( $LINSTALLED )) && !(( $LFORCE )); then
#				log_failure_msg2 "${orange}${cfullfilename} ${reset}Package is already installed. Use the -f option to force reinstallation."
#				continue
#			fi

#			test -e $VARCACHE_ARCHIVES/$cfullfilename.desc || sh_wgetdesc
#			local error_value="${?}"
#			if [ ${error_value} -ne 0 ]; then
#				log_failure_msg2 "ERROR: Downloading ${orange}${cfullfilename}.desc"
#				log_wait_msg "Restarting download ${orange}${cfullfilename}.desc"
#				sh_wgetdesc
#				local error_value="${?}"
#				if [ ${error_value} -ne 0 ]; then
#					log_failure_msg2 "ERROR: Fatal error downloading ${orange}${cfullfilename}.desc. ${reset}Aborting..."
#					exit 1
#				fi
#			fi

#			sh_getdeps

#			if !(( $LAUTO )); then
#				read -p "${blue}:: ${reset}Continue installation? [Y/n]" LDOWNLOAD
#				if [[ $(toupper "${LDOWNLOAD}") = "N" ]]; then
#					return
#				fi
#			fi

#			sh_checksha256sum
#			local error_value="${?}"
#			if [ ${error_value} -ne 0 ]; then
#				log_failure_msg2 "ERROR: Checking sha256sum ${cfullfilename}.sha256"
#				log_wait_msg "Restarting download ${cfullfilename}"
#				sh_wgetfull
#				sh_checksha256sum
#				local error_value="${?}"
#				if [ ${error_value} -ne 0 ]; then
#					log_failure_msg2 "ERROR: Checking sha256sum ${cfullfilename}.sha256. Aborting..."
#					exit 1
#				fi
#			fi

#			if !(( $LINSTALLED )); then
#				log_wait_msg "Wait, installing package ${orange}$cpacote"
#			else
#				log_wait_msg "Wait, reinstalling package ${orange}$cpacote"
#			fi

#         sh_installdownload

#			test -e $VARCACHE_ARCHIVES/$cpacote || sh_wgetpartial
#			local error_value="${?}"
#			if [ ${error_value} -ne 0 ]; then
#				log_failure_msg2 "ERROR: Downloading ${orange}${cfullfilename}"
#				log_wait_msg "Restarting download ${orange}${cfullfilename}"
#				sh_wgetfull
#				local error_value="${?}"
#				if [ ${error_value} -ne 0 ]; then
#					log_failure_msg2 "ERROR: Fatal error downloading ${orange}${cfullfilename}. ${reset}Aborting..."
#					exit 1
#				fi
#			fi

#			if [[ $GETDEPS != " " ]]; then
#				for i in $GETDEPS; do
#					sh_splitpkg ${i}
#					cpacote=${aPKGSPLIT[PKG_FULLNAME]}
#					cpacotebase=${aPKGSPLIT[PKG_BASE]}
#     			case $cpacotebase in
#		      		gcc)	      log_failure_msg2 "Skipping package: $cpacotebase"; continue;;
#     				gcc-libs)   log_failure_msg2 "Skipping package: $cpacotebase"; continue;;
#     				glibc)	   log_failure_msg2 "Skipping package: $cpacotebase"; continue;;
#      				file)	      log_failure_msg2 "Skipping package: $cpacotebase"; continue;;
#  	   			flac)	      log_failure_msg2 "Skipping package: $cpacotebase"; continue;;
#      	      esac
#					test -e $VARCACHE_ARCHIVES/$cpacote || sh_wgetpartial
#      			if !(( $LINSTALLED )); then
#		      		log_wait_msg "Wait, installing package ${orange}$cpacote"
#     			else
#    				log_wait_msg "Wait, reinstalling package ${orange}$cpacote"
#      			fi
#					sh_installpkg -i ${cpacote}
#					local error_value="${?}"
#					if [ ${error_value} -ne 0 ]; then
#						log_failure_msg2 "${red}ERROR:${reset} installing package: ${orange}${cpacote}${reset}"
#					else
#						log_success_msg2 "${green}${cpacote} ${reset}Done. package installation successfully."
#					fi
#				done
#			fi

#         sh_installdoinstallpkg

#			sh_installpkg -i ${cpacote}
#			local error_value="${?}"
#			if [ ${error_value} -ne 0 ]; then
#				log_failure_msg2 "${red}ERROR:${reset} installing package: ${orange}${cpacote}${reset}"
#			else
#				log_success_msg2 "${green}${cpacote} ${reset}Done. package installation successfully."
#			fi
		done
      sh_installdownload
      sh_installdoinstallpkg
	else
		log_failure_msg2 "${red}NOT FOUND ${param}. ${reset}Use ${APP} -Ss for search packages."
		#sh_list ${param}
	fi
	sh_cdroot
}


function sh_search()
{
	local param=$@
	LAUTO=$false
   LFORCE=$false

	#sh_checknet
	sh_list $param
	log_msg "${reset}Use ${APP} -S <package> for package installation."
	sh_cdroot
}


function sh_listmeta()
{
	local LLIST=$true
	local Cont=0

	sh_checkdir "OFF"
	log_wait_msg "${blue}Reading meta package lists in the repository..."
	param=$1

	if [ "$param" == "" ]; then
		param=".*."
	fi

	if [ "$param" == "all" ]; then
		metapkg=$(cat $VARCACHE_SEARCH/folders_metapackages)
	else
		metapkg=$(grep $param $VARCACHE_SEARCH/folders_metapackages)
	fi

	[[ $(toupper "${2}") = "OFF" ]] && LLIST=$false || LLIST=$true

	log_success_msg2 "${blue}Listing... Done"

	if [[ $metapkg != "" ]]; then
		for i in $metapkg; do
			[[ $LLIST = $true ]] && log_success_msg2 "${blue}FOUND ${orange}$i"
			((Cont++))
		done
		 [[ $LLIST = $true ]] && log_success_msg2 "($Cont) meta package(s) found."
	else
		 log_failure_msg2 "${red}${param} NOT FOUND ${reset} ${orange}$i${reset}"
		 log_failure_msg2 "($Cont) meta package(s) found."
		 echo
		 echo -e "${reset}Use: # $0 update - to update with the repository${reset}"
	fi
	sh_cdroot
}


function sh_meta()
{
	local param=$@
	sh_checkparametros ${param}
	sh_listmeta $param

	if [[ $metapkg != "" ]]; then
		if !(( $LAUTO )); then
			echo
			read -p "Install meta package(s)? [Y/n]" LDOWNLOAD
			if [[ $(toupper "${LDOWNLOAD}") = "N" ]]; then
				return
			fi
			LAUTO=$true
		fi
		cd $VARCACHE_ARCHIVES/

		for x in $metapkg; do
			local cmetafile=$x
			local cmetabase=$(echo $cmetafile | cut -d/ -f1)
			local cmetapacote=$(echo $cmetafile | cut -d/ -f2)

			if !(( $GITSITE )); then
				#site normal
            curl --silent -k -O "${SITE}/packages/$x"
			else
				#repositorio github
				curl --silent -k -O "${RAW}/packages/$x"
			fi

			pkgInMeta=$(cat $VARCACHE_ARCHIVES/$cmetapacote)
#			pushd $VARCACHE_INSTALLED/ &>/dev/null
#			local pkginstalled=$(echo *.${PRG})
#			local pkginstalled=$(ls -1 *)
#			popd &>/dev/null
#			local pkginstalled=$(ls -1 *)


			for i in $pkgInMeta; do
				local cfile=$i
#				local cbase=$(echo $cfile | cut -d/ -f1)
#				local cpacote=$(echo $cfile | cut -d/ -f2)
				local cpacote=${i}
				local LINSTALLED=$false

#info "cpacote: $cpacote"
				pkginstalled=
				pkginstalled="$pkginstalled $(grep ^$cpacote: $VARCACHE_SEARCH/packages-installed-split | cut -d: -f1)"

#info $pkginstalled
				{	local item
					index=0
					for item in ${pkginstalled[*]}
					do
#info "$i\n$item\n$cpacote"
						[ $item = $cpacote ] && { LINSTALLED=$true; break; }
						((index++))
					done
				}

				if (( $LINSTALLED )) && !(( $LFORCE )); then
   				log_failure_msg2 "${orange}${cpacote} ${reset}Package is already installed. Use the -f option to force reinstallation."
               continue
				fi

				pkg=$(grep ^$cpacote: $VARCACHE_SEARCH/packages-split | cut -d: -f5)
				if [[ $pkg = "" ]]; then
					log_warning_msg "${orange}${cpacote} ${red}WARNING!! package not in repo! Use 'fetch update' to update the database"
         		continue
				fi

				sh_splitpkg $pkg
				i=$pkg
				cpacote=${aPKGSPLIT[$PKG_FULLNAME]}
				cBaseVersion=${aPKGSPLIT[PKG_BASE_VERSION]}

				test -e $VARCACHE_ARCHIVES/$cpacote || sh_wgetpartial
				#sh_checksha256sum

				local error_value="${?}"
				if [ ${error_value} -ne 0 ]; then
					log_failure_msg2 "ERROR: Checking sha256sum ${cpacote}.sha256... FAIL"
    				log_wait_msg "Restarting download ${cpacote}..."
    				sh_wgetpartial
    				#sh_checksha256sum
					local error_value="${?}"
					if [ ${error_value} -ne 0 ]; then
						log_failure_msg2 "ERROR: Checking sha256sum ${cpacote}.sha256... FAIL. Aborting..."
						exit 1
					fi
				fi

				if !(( $LINSTALLED )); then
					log_info_msg "Installing package ${orange}$cpacote"
				else
					log_info_msg "Reinstalling package ${orange}$cpacote"
				fi

				#ERROR=$(sh_installpkg -i $cpacote 2>&1>/dev/null)
				sh_installpkg -i $cpacote
				evaluate_retval

				local error_value="${?}"
				if [ ${error_value} -ne 0 ]; then
					log_failure_msg2 "ERROR: installing package ${orange}${cpacote}... FAIL"
				fi
			done
		done
	fi
	sh_cdroot
}


function sh_recreatefilepackagesinstalled()
###########################################
{
	local pkgNumber=0
	local s

	#sh_checkdir "OFF"
	log_wait_msg "${pink}Reading lists of installed packages..."
	param=$@

	log_info_msg "${green}Checking packages"
	rm -f $VARCACHE_INSTALLED/*                     &> /dev/null
	rm -f $VARCACHE_SEARCH/packages-installed       &> /dev/null
	rm -f $VARCACHE_SEARCH/packages-installed-split &> /dev/null

	pushd $VARLIB_DESC/ &>/dev/null
	aCachedesc=($(echo *.desc))
	for item in ${aCachedesc[*]}; do
		cfileinstalled=$(echo ${item%.desc*})
		cfileinstalled=$(echo ${cfileinstalled%.${PRG}*})
		echo ${cfileinstalled} >> $VARCACHE_SEARCH/packages-installed
		sh_splitpkg ${cfileinstalled}
		echo "${aPKGSPLIT[$PKG_BASE]}:${aPKGSPLIT[$PKG_VERSION]}:${aPKGSPLIT[$PKG_BUILD]}:${aPKGSPLIT[$PKG_FULLNAME]}" >> $VARCACHE_SEARCH/packages-installed-split
		> $VARCACHE_INSTALLED/${cfileinstalled}
		mv $item $cfileinstalled.desc  &> /dev/null    #consertar pacotes antigos
	done
	popd  &>/dev/null

	cat $VARCACHE_SEARCH/packages-installed|sort|uniq >/tmp/packages-installed
	cp /tmp/packages-installed $VARCACHE_SEARCH/packages-installed
	rm -f /tmp/packages-installed

	local nfilesinstalled=${#aCachedesc[*]}
	evaluate_retval
}


function sh_listinstalled()
{
	local param=$@
	local pkgNumber=0
	local s
	local LLIST=$true
	local LEXACT=$false
	local LALL=$false
	local cListSearch
	local ntotalpkg=0

	[[ -e $VARCACHE_SEARCH/packages-installed ]] || > /$VARCACHE_SEARCH/packages-installed
	public_ntotal_pkg_installed=$(grep ^ $VARCACHE_SEARCH/packages-installed | wc -l)
	public_ntotal_pkg_listed=$public_ntotal_pkg_installed
	pkginstalled=

	for s in ${param[@]}; do
		[[ $(toupper "${s}") = "-Y" ]]    && { LAUTO=$true; continue; }
     	[[ $(toupper "${s}") = "-F" ]]    && { LFORCE=$true; continue; }
     	[[ $(toupper "${s}") = "OFF" ]]   && { LLIST=$false; continue; }
		[[ $(toupper "${s}") = "EXACT" ]] && { LEXACT=$true; continue; }
		[[ $(toupper "${s}") = "ALL" ]]   && { LALL=$true; continue; }
		cListSearch="$cListSearch $(echo ${s})"
	done

	if (( $LALL )) || [[ "$cListSearch" == "" ]]; then
		#pkginstalled=$(awk -F: '{print $1}' $VARCACHE_SEARCH/packages-installed-split | grep ^)
		pkginstalled=$(grep ^ $VARCACHE_SEARCH/packages-installed)
	else
		for x in ${cListSearch}; do
			if (( $LEXACT )); then
				pkginstalled="$pkginstalled $(grep ^$x: $VARCACHE_SEARCH/packages-split | cut -d: -f5)"
			else
				pkginstalled="$pkginstalled $(grep $x $VARCACHE_SEARCH/packages-installed)"
			fi
		done
	fi


	if (( $LLIST )); then
		log_wait_msg "${green}Listing..."
		arr=(${pkginstalled[*]})
		ntotalpkg=${#arr[*]}
		if [[ "${#pkginstalled}" -gt 0 ]]; then # pacote?
			pkgNumber=0
			printf "%12sPackage(${ntotalpkg})%33sversion%8sfullname\n"
			for i in $pkginstalled; do
				((pkgNumber++))
				sh_splitpkg "${i}"
#				log_success_msg2 "${green}FOUND ($pkgNumber) ${orange}${aPKGSPLIT[PKG_BASE]} ${aPKGSPLIT[PKG_VERSION]}${reset}"
				printf "${green}%s(%04d) ${orange}%-43s ${reset}%-15s%s\n" "     " "$pkgNumber" "${aPKGSPLIT[$PKG_BASE]}" "${aPKGSPLIT[$PKG_VERSION]}" "${aPKGSPLIT[$PKG_FOLDER_DIR]}/${aPKGSPLIT[$PKG_FULLNAME]}"
			done
			public_ntotal_pkg_listed=$pkgNumber
			log_msg "($pkgNumber) package(s) installed."
		else
			log_msg "($pkgNumber) package(s) found."
			echo
			echo -e "${reset}Use: # ${APP} -Sy - to update with the repository${reset}"
		fi
	else
		pkgNumber=0
		for i in $pkginstalled; do
			((pkgNumber++))
		done
		public_ntotal_pkg_listed=$pkgNumber
	fi
	sh_cdroot
	return $pkgNumber
}


function sh_listforinstall()
{
	local pkgNumber=0
	local s
	local param=$@
	local LLIST=$true
	local LEXACT=$false
	local LALL=$false
	local LDEPS=$true
	local ncontapkgforinstall=0
	local cListSearch
	local arr

	[[ -e $VARCACHE_SEARCH/packages-installed ]] || > /$VARCACHE_SEARCH/packages-installed
	public_ntotal_pkg_installed=$(grep ^ $VARCACHE_SEARCH/packages-installed | wc -l)
	public_ntotal_pkg_listed=$public_ntotal_pkg_installed
	pkgforinstall=

	for s in ${param[@]}; do
		[[ $(toupper "${s}") = "--NODEPS" ]]    && { LDEPS=$false; continue; }
		[[ $(toupper "${s}") = "-Y" ]]    && { LAUTO=$true; continue; }
     	[[ $(toupper "${s}") = "-F" ]]    && { LFORCE=$true; continue; }
     	[[ $(toupper "${s}") = "OFF" ]]   && { LLIST=$false; continue; }
		[[ $(toupper "${s}") = "EXACT" ]] && { LEXACT=$true; continue; }
		[[ $(toupper "${s}") = "ALL" ]]   && { LALL=$true; continue; }
		cListSearch="$cListSearch $(echo ${s})"
	done

	if (( $LALL )) || [[ "$cListSearch" == "" ]]; then
		pkgforinstal=$(grep ^ $VARCACHE_SEARCH/packages-split)
	else
		for x in ${cListSearch}; do
			if (( $LEXACT )); then
				pkgforinstall="$pkgforinstall $(grep ^$x: $VARCACHE_SEARCH/packages-split | cut -d: -f5)"
			else
				pkgforinstall="$pkgforinstall $(grep $x $VARCACHE_SEARCH/packages-split)"
			fi
		done
	fi

	if (( $LLIST )); then
#		log_wait_msg "${green}Listing..."
   	arr=(${pkgforinstall[*]})
   	ncontapkgforinstall=${#arr[*]}
		if [[ "${#pkgforinstall}" -gt 0 ]]; then # pacote?
			pkgNumber=0
#      	printf "%12sPackage(${ncontapkgforinstall})%34sversion%8sfullname\n"
  			sh_getdeps $LDEPS
      	arr=(${pkgforinstall[*]})
      	ncontapkgforinstall=${#arr[*]}

#			for i in $pkgforinstall; do
#				((pkgNumber++))
#				sh_splitpkg "${i}"
#			   local cfullfilename=${aPKGSPLIT[PKG_FULLNAME]}
#   			sh_getdeps
#         	printf "${green}%s(%04d) ${orange}%-43s ${reset}%-15s%s\n" "     " "$pkgNumbr" "${aPKGSPLIT[$PKG_BASE]}" "${aPKGSPLIT[$PKG_VERSION]}" "${aPKGSPLIT[$PKG_FULLNAME]}"
#			done

#			public_ntotal_pkg_listed=$pkgNumber
			public_ntotal_pkg_listed=$ncontapkgforinstall
			#log_msg "($public_ntotal_pkg_listed) package(s) for install."
			echo
		else
			log_msg "($pkgNumber) package(s) found."
			echo
			echo -e "${reset}Use: # ${APP} -Sy - to update with the repository${reset}"
		fi
	else
		pkgNumber=0
		for i in $pkgforinstall; do
			((pkgNumber++))
		done
		public_ntotal_pkg_listed=$pkgNumber
	fi
	sh_cdroot
	return $pkgNumber
}


function sh_installed()
{
	local param=$@

	sh_recreatefilepackagesinstalled
	sh_listinstalled $param

	if [[ $pkginstalled != "" ]]; then
		for i in $pkginstalled; do
			local cfile=$i
			local cbase=$(echo $cfile | cut -d/ -f1)
			local cpacote=$(echo $cfile | cut -d/ -f2)

			test -d $VARCACHE_ARCHIVES || mkdir -p $VARCACHE_ARCHIVES
			cd $VARCACHE_ARCHIVES/
			PS3='Please enter your choice: '
			options=("Reinstall" "Remove" "Quit")
			select opt in "${options[@]}"
			do
				case $opt in
					"Reinstall")
						sh_search "-R" "$cpacote" "-Y"
						return 2
						;;
					"Remove")
						sh_remove "$cpacote" "-Y"
						return 2
						;;
					"Quit|n|N")
						exit 0
						break
						;;
					*) exit 0
						break
						echo "invalid option $REPLY";;
				esac
			done
		done
	fi
	sh_cdroot
}


function sh_listremoved()
{
	sh_checkdir "OFF"
	log_wait_msg "Reading lists of removed packages..."
	param=$1

	if [ "$param" == "" ]; then
		param=".*."
	fi

	log_info_msg "Checking packages"
	pushd $VARCACHE_REMOVED/ &>/dev/null
	aCache=($(echo *.${PRG}))

	rm -f $VARCACHE_SEARCH/packages-removed
	for item in ${aCache[*]}; do
    	echo $item|sed 's/.'${PRG}'//g' >> $VARCACHE_SEARCH/packages-removed
	done
	popd  &>/dev/null
	local nfilesremoved=${#aCache[*]}
	evaluate_retval

	if [ "$param" == "all" ]; then
		pkgremoved=$(cat $VARCACHE_SEARCH/packages-removed)
	else
		pkgremoved=$(grep $param $VARCACHE_SEARCH/packages-removed)
	fi

	declare -g pkgNumber=0
	log_success_msg2 "Listing... Done"

	if [[ $pkgremoved != "" ]]; then
		for i in $pkgremoved; do
			log_success_msg2 "${green}FOUND ${reset} ${orange}$i${reset}"
			((pkgNumber++))
		done
		log_success_msg2 "($pkgNumber) package(s) removed by $0"
	else
		log_failure_msg2 "${red}$param NOT FOUND ${reset} ${orange}$i${reset}"
		log_failure_msg2 "($pkgNumber) package(s) removed by $0."
		echo
		echo -e "${reset}Use: # $0 update - to update with the repository${reset}"
	fi
	sh_cdroot
	return $pkgNumber
}


function sh_removed()
{
	sh_listremoved $1

	if [[ $pkgremoved != "" ]]; then
		if [ $pkgNumber = '1' ]; then
			for i in $pkgremoved; do
				local cfile=$i
				local cbase=$(echo $cfile | cut -d/ -f1)
				local cpacote=$(echo $cfile | cut -d/ -f2)

				test -d $VARCACHE_ARCHIVES || mkdir -p $VARCACHE_ARCHIVES
				cd $VARCACHE_ARCHIVES/
				echo
				read -p "Reinstall package? [Y/n]" LINSTALL

				if [[ $(toupper "${LINSTALL}") = "Y" ]] || [[ $(toupper "${LINSTALL}") = "" ]]; then
					sh_search "$cpacote" "-Y"
					return 0
				fi

			done
		fi
		echo
		echo "use $APP -S for install package"
	fi
	sh_cdroot
}


function _LIST_ARCHIVES_DIRECTORIES()
{
	local packname="${1}.list"
	local LIST_CLEAN_DIRECTORIES

	sed -i "
        s/^\.\///g
        s/^\///g
        s|\/$||g
        /^\./d
        /^ *$/d
        /^bin$/d
        /^info$/d
        /^boot$/d
        /^dev$/d
        /^etc$/d
        /^home$/d
        /^lib$/d
        /^lib64$/d
        /^media$/d
        /^mnt$/d
        /^opt$/d
        /^proc$/d
        /^root$/d
        /^run$/d
        /^sbin$/d
        /^srv$/d
        /^sys$/d
        /^tmp$/d
        /^usr$/d
        /^var$/d
        /^info\/pos\.sh$/d
        /^info\/pre\.sh$/d
        /^info\/desc/d
        /info\/rm.sh/d
        /^var\/lib\/banana\/list\/.*\.list/d
        /^var\/lib$/d
        /^var\/lib\/banana/d
        /^var\/lib\/banana\/list/d
        /^var\/lib\/banana\/remove/d
	" "${VARLIB_LIST}/${packname}"

	LIST_CLEAN_DIRECTORIES=(
		'var'
		'lib'
		'media'
		'usr'
		'usr/share'
		'srv'
	)

	while read view; do
		if [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[0]}/(cache|lib|local|lock|log|mail|opt|run|spool|tmp)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${VARLIB_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[1]}/(lib64)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${VARLIB_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[2]}/(cdrom|floppy)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${VARLIB_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[3]}/(bin|etc|lib|lib\/(pkgconfig)|local|share|doc|include|libexec|sbin|src)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${VARLIB_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[4]}/(keymaps|fonts|pixmaps|applications|doc|man|man\/man[[:digit:]]+|man\/.{2})$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${VARLIB_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[5]}/(www|httpd)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^${view}$/d" "${VARLIB_LIST}/${packname}"
		fi
	done < "${VARLIB_LIST}/${packname}"
}


function _SUBSHELL_STATUS()
{
	[[ "$?" -ne '0' ]] && return 1 || return 0
}


function _MANAGE_SCRIPTS_AND_ARCHIVES()
{
	sh_splitpkg "${1}"
#	local packname="${1/%.${PKG_EXT}/}"
	local packname=${aPKGSPLIT[PKG_BASE_VERSION]}
	local dir_desc="${VARLIB_LIST/list/desc}"

	if ! [[ -e "/tmp/info/desc" ]]; then
		log_failure_msg2 "ERROR! /info/desc does not exist. ABORT!"
		return 1
	fi

	pushd "/tmp/info/" &>/dev/null

	if ! mv 'desc' "$VARLIB_DESC/${packname}.desc" ; then
		log_failure_msg2 "ERROR! could not move desc to /${dir_desc}/${packname}.desc"
		log_failure_msg2 "ABORTING..."
		return 1
	fi

	if [[ -e "pos.sh" ]]; then
		bash "pos.sh"
	fi

	if [[ -e "/tmp/info/.INSTALL" ]]; then
		source .INSTALL &> /dev/null
		post_install
		post_upgrade
	fi

	if [[ -e "rm.sh" ]]; then
		if ! mv 'rm.sh' "$VARLIB_REMO/${packname}.rm" ; then
			log_failure_msg2 "ERROR! could not move rm.sh to $VARLIB_REMO/${packname}.rm"
			log_failure_msg2 "ABORTING..."
			return 1
		fi
    fi

	popd &>/dev/null
	[[ -d "/info/"     ]] && rm -r "/info/"
	[[ -d '/tmp/info/' ]] && rm -r "/tmp/info/"
	[[ -e '/.BUILDINFO' ]] && rm "/.BUILDINFO"
	[[ -e '/.MTREE' ]] && rm "/.MTREE"
	[[ -e '/.PKGINFO' ]] && rm "/.PKGINFO"
	[[ -e '/.INSTALL' ]] && rm "/.INSTALL"
	return 0
}


function _CREATE_LIST()
{
	local packname="$1"

#info "name_version_build: $name_version_build"

	if ! tar --list --file "$packname" > "${VARLIB_LIST}/${name_version_build}.list"; then
		log_failure_msg2 "ERROR! Can not create ${VARLIB_LIST}/${name_version_build}.list"
		return 1
	fi
	return 0
}


function _GENERATE_DESC()
{
	local i
	local DESC_PACKNAME="$1"
	local DESC_VERSION="$2"
	local DESC_BUILD="$3"

	[[ ! -d "info" ]] && mkdir info
    _CAT > "info/desc" << EOF
######################################################################
# Generated with fetch
# Generated with alienpkg
######################################################################
maintainer='$MAINTAINER'
pkgname='$DESC_PACKNAME'
version='$DESC_VERSION'
build='$DESC_BUILD'
license='$LICENSE'
lfs_version='$LFS_VERSION'
lfs_init='$LFS_INIT'
arch='$ARCH'
distro='$DISTRO'
desc='$DESC'
size='$SIZE'
url='$URL'
dep=('')
EOF

	for i in ${deps[*]}
	do
		echo depend="'$i'" >> $descme
	done
	return 0
}


function _INPUT_NULL_PARAMETER()
{
	pkg=$1

	local arr
	if [[ -z "$pkg" ]]; then
		pkg=$(echo $PWD | sed 's/\// /g' | awk '{print $NF}'|sed 's/-/_/g'| sed 's/\(.*\)_/\1 /'|sed 's/ /-/g')
		arr=($pkg)
		[[ ${#arr[*]} -gt 2 ]] && pkg="${arr[0]}_${arr[1]} ${arr[2]}"
		pkg=${pkg}-${DESC_BUILD}
	fi
	sh_info "INPUT_NULL" $pkg
	return 0
}

function _NAME_FORMAT_PKG()
{
	local packname="$1"

	re="\b${PKG_EXT}\b"
	if ! [[ "$packname" =~ .*\.${re}$ ]]; then
		log_failure_msg2 "ERROR Package need finish .${PKG_EXT}"
		return 1
	fi
	return 0
}

function sh_generatepkg()
{

	shift
	local param=$@
	local inc=0

	if [[ ${#param} -eq 0 ]]; then # run standalone
		LAUTO=$true
		LFORCE=$true
		LLIST=$false
		pkg="${PWD##*/}-2"
	else
		for s in ${param[@]}; do
			if [[ $(toupper "${s}") = "-Y" ]]; then
				LAUTO=$true
			elif [[ $(toupper "${s}") = "-F" ]]; then
				LFORCE=$true
			elif [[ $(toupper "${s}") = "OFF" ]]; then
				LLIST=$false
			else
				pkg="$s"
				continue
			fi
		done
	fi

	log_info_msg "(${ncount}/${ntotalpkg}) Generating info for package $pkg"
	if [[ ! -e "info/desc" ]]; then
		LFORCE=$true
	fi
	if (( $LAUTO )) || (( $LFORCE )); then
		for take in 'field_one' 'field_two' 'field_three'; do
			let inc++
			eval $take="$(echo "$pkg" | cut -d '-' -f ${inc})" # Expanda e pegue o seu devido valor
		done
		[[ -z "$field_three" ]] && field_three=$DESC_BUILD
		[[ -z "$DESC"        ]] && DESC="$field_one-$field_two-$field_three"
		_GENERATE_DESC "$field_one" "$field_two" "$field_three" || return 1
	fi
	evaluate_retval
	unset check_var
	return 0
}


function sh_doinstallpkg()
{
	(
	local packname="$1"
	local name_version_build
	local tmp_pack
	local PRE_SH='pre.sh'
	local INSTALL_SH='.INSTALL'

	if ! tar --use-compress-program=zstd --extract --preserve-permissions --touch --file "${packname}" -C "/tmp/" "./${descme}"; then
		log_failure_msg2 "${red}ERROR! ${reset}I could not unzip the file: ${orange}${packname}.desc${reset}"
		return 1
	fi
	source "/tmp/${descme}" || log_failure_msg2 "ERROR! Not load ${descme}"
	if [[ ! -e "/tmp/${descme}" ]]; then
		log_failure_msg2 "ERROR! Could not load /tmp/${descme}. Archive not exist. ABORT!"
		return 1
	fi

	if tar --use-compress-program=zstd --list --file "${packname}" "./info/$PRE_SH" &>/dev/null; then
		if ! tar --use-compress-program=zstd --extract --preserve-permissions --file "$packname" -C /tmp "./info/$PRE_SH" &>/dev/null; then
			log_failure_msg2 "ERROR! Cannot extract ${PRE_SH}, ABORT"
			return 1
		fi
		bash "/tmp/info/$PRE_SH"
	fi

	if tar --use-compress-program=zstd --list --file "${packname}" "./info/$INSTALL_SH" &>/dev/null; then
		if ! tar --use-compress-program=zstd --extract --preserve-permissions --file "$packname" -C /tmp "./info/$INSTALL_SH" &>/dev/null; then
			log_failure_msg2 "ERROR! Cannot extract ${INSTALL_SH}, ABORT"
			return 1
		fi
	fi

	#name_version_build="${pkgname}-${version}-${build}"
	sh_splitpkg ${packname}
	name_version_build=${aPKGSPLIT[$PKG_ARCH]}

	tar --use-compress-program=zstd --extract --preserve-permissions --touch --file "${packname}" -C / | tee -a ${VARLIB_LIST}/"${name_version_build}.list" &>/dev/null || return 1

	_CREATE_LIST "$1" || return 1
	_MANAGE_SCRIPTS_AND_ARCHIVES "${name_version_build}" || return 1
#	_MANAGE_SCRIPTS_AND_ARCHIVES "${1}" || return 1
	_LIST_ARCHIVES_DIRECTORIES "${name_version_build}"
	)
	_SUBSHELL_STATUS
}


function sh_initinstallpkg()
{
	local pkg
	local param=$@
	local package
	local	xdir=$PWD/

	shopt -s nullglob       # enable suppress error message of a command 
	if [[ "${param}" == "" ]] || [[ $(toupper "${param}") = "ALL" ]] || [[ $(toupper "${param}") = "ALL OFF" ]]; then
		pkg=$(ls -1 "$VARCACHE_ARCHIVES/*.${PRG}" &>/dev/null)
	   if [[ "${#pkg}" -eq 0 ]]; then # none?
   		pkg=$(ls -1 *.${PRG} &>/dev/null)
	   fi
	else
		for s in ${param[@]}; do
			if [[ $(toupper "${s}") = "-Y" ]]; then
				LAUTO=$true
			elif [[ $(toupper "${s}") = "-F" ]]; then
				LFORCE=$true
			elif [[ $(toupper "${s}") = "OFF" ]]; then
				LLIST=$false
			else
				xdir=$(dirname $s)
				cfile=$(echo $s | sed 's/\// /g' | awk '{print $NF}')
				files=$(ls -1 $xdir/*.${PRG} |grep "$cfile")
				pkg="$pkg $(echo $files| grep $cfile)"
			fi
		done
	fi

	log_wait_msg "${blue}Listing..."
	pkgCheckNumber=0
	LLIST=$true

	if [[ "${#pkg}" -gt 1 ]]; then # pacote?
		for i in $pkg; do
			[[ $LLIST = $true ]] && log_success_msg2 "${blue}FOUND local package in ${xdir}${orange}$i"
			((pkgCheckNumber++))
		done
		[[ $LLIST = $true ]] && log_success_msg2 "($pkgCheckNumber) package(s) found."

		if (( $pkgCheckNumber )); then
			if !(( $LAUTO )); then
				echo
				conf "Install Pakages(s)?"
				LAUTO=$?
			fi
		fi
	else
		msg "${orange}$param ${red}NOT FOUND ${reset}local package in ${orange}${VARCACHE_ARCHIVES}${reset}"
		msg "${orange}$param ${red}NOT FOUND ${reset}local package in ${orange}${xdir} ${reset}"
		log_msg "($pkgCheckNumber) package(s) found."
		echo
		echo -e "${reset}Use: # $0 update - to update with the repository${reset}"
	fi

	if (( $LAUTO )); then
		for package in $pkg
		do
			log_wait_msg "Installing local package ${orange}$package"
#			ERROR=$(sh_installpkg -i $package 2>&1>/dev/null)
			sh_installpkg -i $package
		done
	fi
	shopt -u nullglob       # disable suppress error message of a command 
}


function sh_installpkg()
{
	local _pkg=
	shift
	while [[ -n "$1" ]]; do
		sh_doinstallpkg "$1"  || return 1
		retval=${?}
#		_pkg=$(echo ${1}|sed 's/\// /g'|awk '{print $NF}'|sed 's/.'${PKG_EXT}'//g')
		sh_splitpkg "${1}"
		_pkg=${aPKGSPLIT[PKG_BASE_VERSION]}
		[[ $retval = 0 ]] && > $VARCACHE_INSTALLED/${_pkg}
		[[ $retval = 0 ]] && rm -f $VARCACHE_REMOVED/${_pkg}
		[[ $retval = 0 ]] && rm -f "$VARCACHE_REMOVED/${aPKGSPLIT[$PKG_ARCH]}.${PRG}"
		[[ $retval = 0 ]] && sed -i '/'${_pkg}'/d' $VARCACHE_SEARCH/packages-installed
		[[ $retval = 0 ]] && sed -i '/'${_pkg}'/d' $VARCACHE_SEARCH/packages-installed-split
		[[ $retval = 0 ]] && echo ${_pkg} >> $VARCACHE_SEARCH/packages-installed
		[[ $retval = 0 ]] && echo "${aPKGSPLIT[$PKG_BASE]}:${aPKGSPLIT[$PKG_VERSION]}:${aPKGSPLIT[$PKG_BUILD]}:${aPKGSPLIT[$PKG_ARCH]}:${aPKGSPLIT[$PKG_FULLNAME]}" >> $VARCACHE_SEARCH/packages-installed-split
		shift
	done
	return 0
}


function print()
{
	[[ "$printyeah" = '1' ]] && echo -e "$@"
}


function _REMOVE_NOW()
{
	local packname="${1/%.${PKG_EXT}/}"
	local a='0'
	local d='0'
	local l='0'
	local archive

	[[ -z "$name_version_build" ]] && { log_failure_msg2 "ERROR! Variable 'name_version_build' NULL. ABORT"; return 1 ;}
	pushd "/" &>/dev/null

	if [[ -e "${VARLIB_REMO}/${packname}.rm" ]]; then
		sed -E "/rm[[:space:]]+\-(rf|fr)/d" "${VARLIB_REMO}/${packname}.rm" &>/dev/null
		bash "${VARLIB_REMO}/${packname}.rm"
		if [[ -e "${VARLIB_REMO}/${packname}.rm" ]]; then
			rm "${VARLIB_REMO}/${packname}.rm"
		fi
	fi

	while IFS= read thefile; do
		if [[ -f "$thefile" ]]; then
			rm "$thefile" &>/dev/null && print "Delete\t${thefile}"
		fi
	done < "${VARLIB_LIST}/${packname}.list"
	unset archive

	while IFS= read thelink; do
		if [[ -L "$thelink" ]]; then
			unlink "$thelink" &>/dev/null
		fi
	done < "${VARLIB_LIST}/${packname}.list"
	unset archive

	while IFS= read thedir; do
		if [[ -d "$thedir" ]] && [[ -z "$(ls -A ${thedir})" ]]; then
			rmdir -p "${thedir}" &>/dev/null
		fi
	done < "${VARLIB_LIST}/${packname}.list"

	for removeitem in "desc" "list"; do
		case $removeitem in
			desc)   DIREC="$VARLIB_DESC";;
			list)   DIREC="$VARLIB_LIST";;
		esac
		if [[ -e "${DIREC}/${packname}.${removeitem}" ]]; then
			if ! rm "${DIREC}/${packname}.${removeitem}"; then
				log_failure_msg2 "ERROR! It was not possible remove ${DIREC}/${packname}.list"
				return 1
			fi
		else
			continue
		fi
	done
	popd &>/dev/null
	IFS=$SAVEIFS
	return 0
}


function _GPG_SIGN()
{
	local package="$1"
	local sig='sig'

	#Pacote existe?
	if [[ ! -e "${package}.${PKG_EXT}" ]]; then
		echo "${red}[ERRO]${end} Unable to sign package. ${package}.${PKG_EXT}"
		echo "Reason: Package not found."
		echo "For security reasons, do not pass the package on to third parties."
		return 1
	fi

	[ "$REWRITE_SIG" = "1" ] && rm -f ../${package}.${PKG_EXT}.${sig}
	[ "$REWRITE_SIG" = "1" ] && rm -f ${package}.${PKG_EXT}.${sig}

	which gpg &> /dev/null
	if [ $? = 0 ]; then
		#Gerando Assinatura no pacote
		gpg --detach-sign --pinentry-mode loopback "${package}.${PKG_EXT}" &>/dev/null || \
		gpg --detach-sign "${package}.${PKG_EXT}" || return 1
		echo -e "${blue}[Create]${end} Your ${sig} on:   ../${package}.${PKG_EXT}.${sig}"
	fi
	return 0
}


function _VERIFY_ON()
{
	local package="$1"

	#sh_generatepkg "$1"

	(
	local dir_info='info'  # Diretorio info que contem informações como (desc)
	local info_desc='desc' # Descrição do pacote

	if [[ ! -d "$dir_info" ]]; then # Diretório info existe?
		log_failure_msg2 "${red}[ERROR!]${end} ${pink}${dir_info}${end} directory\n"
		log_failure_msg2 "It's necessary your package have the DIRECTORY ${pink}info${end}."
		log_failure_msg2 "${pink}${dir_info}${end} its a directory store important archives."
		log_failure_msg2 "For more information use -h, --help."
		exit 77
	elif [[ ! -e "${dir_info}/${info_desc}" ]]; then
		log_failure_msg2 "${red}[ERROR!]${end} ${pink}${info_desc}${end} archive\n"
		log_failure_msg2 "It's necessary your package have the ARCHIVE ${pink}desc${end} inside of directory '${dir_info}'."
		log_failure_msg2 "${pink}${info_desc}${end} have informations of your package."
		log_failure_msg2 "For more information use -h, --help."
		exit 1
	else
		# Se caiu aqui está tudo certo, vamo então conferir as variaveis do 'desc'
		# Se alguma variavel estiver nula não podemos continuar.
		source ${dir_info}/${info_desc} # Carregando arquivo.

		if [[ -z "$maintainer" ]]; then
			log_failure_msg2 "Check ${pink}${info_desc}${end}, sh_VARIABLE ${blue}maintainer${end} null"
			log_failure_msg2 "Enter the name of the package maintainer into variable maintainer."
			#exit 1
		elif [[ -z "$pkgname" ]]; then
			log_failure_msg2 "Check ${pink}${info_desc}${end}, VARIABLE ${blue}pkgname${end} null"
			log_failure_msg2 "Enter the name of the package into variable pkgname."
			#exit 1
		elif [[ -z "$version" ]]; then
			log_failure_msg2 "Check ${pink}${info_desc}${end}, VARIABLE ${blue}version${end} null"
			log_failure_msg2 "Enter a version of software into variable version."
			#exit 1
		elif [[ -z "$build" ]]; then
			log_failure_msg2 "Check ${pink}${info_desc}${end}, VARIABLE ${blue}build${end} null"
			log_failure_msg2 "Enter the build number of package."
			#exit 1
		elif [[ -z "$desc" ]]; then
			log_failure_msg2 "Check ${pink}${info_desc}${end}, VARIABLE ${blue}desc${end} null"
			log_failure_msg2 "Detail a small description into variable desc."
			#exit 1
		elif [[ -z "$url" ]]; then
			log_failure_msg2 "Check ${pink}${info_desc}${end}, VARIABLE ${blue}url${end} null"
			log_failure_msg2 "Enter a url of project/software into variable url."
			#exit 1
		fi

        # Conferindo se o nome do pacote e versão batem com o que
        # o usuario passou em linha, se não bater não devemos continuar.

#        if [[ "$pkgname" != "$(echo "$package" | cut -d '-' -f '1')" ]]; then
#            echo -e "Check ${pink}${info_desc}${end}, VARIABLE ${blue}pkgname${end} it different"
#            echo "of the name you entered as an argument. Check and return ;)"
#            exit 1

#        elif [[ "$version" != $(echo "$package" | cut -d '-' -f '2' | sed 's/\.'${PKG_EXT}'//') ]]; then
#            echo -e "Check ${pink}${info_desc}${end}, VARIABLE ${blue}version${end} it different"
#            echo "of the version you entered as an argument. Check and return ;)"
#            exit 1

#        elif [[ "$build" != $(echo "$package" | cut -d '-' -f '3' | sed 's/\.'${PKG_EXT}'//') ]]; then
#            echo -e "Check ${pink}${info_desc}${end}, VARIABLE ${blue}build${end} it different"
#            echo "of the version you entered as an argument. Check and return ;)"
#            exit 1
#        fi
		fi

		#Verificando se rm -rf está presente em um dos scripts.
		for check_script in 'pre.sh' 'pos.sh' 'rm.sh'; do
			if [[ -e "${dir_info}/${check_script}" ]]; then
#			if _GREP 'rm[[:space:]]+\-(rf|fr)' "${dir_info}/${check_script}" 1>&4 2>&3; then
			if _GREP 'rm[[:space:]]+\-(rf|fr)' "${dir_info}/${check_script}" &>/dev/null; then
				log_failure_msg2 "${red}[CRAZY!]${end} ${PWD}/${dir_info}/$check_script contain command rm -rf. ABORTED NOW."
				return $false
			fi
		fi
   	done
 	)
	_SUBSHELL_STATUS
}


function _CREATE_PKG()
{
	local package="${1/%.${PKG_EXT}/}"
	local ext_desc='desc'

	if tar --use-compress-program zstd --create --file ../${package}.${PKG_EXT} .; then
		cp "$descme" ../${package}.${PKG_EXT}.${ext_desc} &>/dev/null
		pushd .. &>/dev/null
		sha256sum ${package}.${PKG_EXT} > ${package}.${PKG_EXT}.sha256

		if [[ "$GPG_SIGN" = '1' ]]; then
			_GPG_SIGN "${package}" || return 1
			popd &>/dev/null
		else
			return 0
		fi
	fi
	evaluate_retval
}


function sh_createpkg()
{
	shift
	local param=$@
	local s
	local ret

	for s in ${param[@]}
	do
		if [[ $(toupper "${s}") = "-Y" ]]; then
			LAUTO=$true
		elif [[ $(toupper "${s}") = "-F" ]]; then
			LFORCE=$true
		elif [[ $(toupper "${s}") = "OFF" ]]; then
			LLIST=$false
		else
			pkg="$s"
			#break
			continue
		fi
	done

	if [[ -z "$pkg" ]] ; then
		local pkg=$(echo $PWD |sed 's/\// /g'|awk '{print $NF}')
	fi

	log_wait_msg "(${ncount}/${ntotalpkg}) Building package $pkg"
	#sh_generatepkg $pkg $pkg $LAUTO $LFORCE
	sh_generatepkg $pkg $pkg -Y -F $4 $5
	_NAME_FORMAT_PKG "$pkg.${PKG_EXT}" || exit 1
	_VERIFY_ON "$pkg"
	ret=$?
	if [ $ret -ne 0 ]; then
		exit 1
	fi
	_CREATE_PKG "$pkg" || exit 1
	log_info_msg "(${ncount}/${ntotalpkg}) Generating package $pkg"
	unset check_var
}


function sh_alienpkg_init()
{
	log_wait_msg "Loading /usr/libexec/fetch/core.sh"
	#source /usr/libexec/fetch/core.sh
	unset BUILDDIR
	unset size
}


function sh_alienpkg_pkgsize()
{
	size="$(/usr/bin/du -sk --apparent-size)"
   size="$(( ${size%%[^0-9]*} * 1024 ))"
}


function sh_alienpkg_initvars()
{
	ALIEN_CACHE_DIR="${ALIEN_CACHE_DIR:=/var/cache/pacman/pkg}"
	PKGS=$@
#	EXT="${EXT:-.pkg.tar.xz}"
	BUILDDIR="${PKGDIR:-/lfs/arch}"
	GITDIR="${GITDIR:-/github/ChiliOS}"
}


function sh_alienpkg_exec()
{
	local pkg
	local param=$@
	local package
	local LFORCELOCAL=
	local LFIND=$false
	local LALL=$false
	local mtime=0
	local string=
	local ntotalpkg=0
	local ncount=0
	local arraypkg=

  	for s in ${param[@]}; do
	 	if [[ "${s}" == "" ]] || [[ $(toupper "${s}") = "ALL" ]] || [[ $(toupper "${s}") = "ALL OFF" ]]; then
			LALL=$true
     	elif [[ $(toupper "${s}") = "-Y" ]]; then
        	LAUTO=$true
		elif [[ $(toupper "${s}") = "-F" ]]; then
			LFORCE=$true
		elif [[ $(toupper "${s}") = "OFF" ]]; then
			LLIST=$false
		elif [[ $(toupper "${s:0:7}") = "-CTIME=" ]]; then
			LFIND=$true
			mtime=${s:7}
		else
			string="$string ${s}"
		fi
	done

	if (( $LALL )); then
		if !(( $LFIND )); then
			pkg=$(ls -1 $ALIEN_CACHE_DIR/*.{zst,xz})
		else
			pkg=$(find $ALIEN_CACHE_DIR/ -type f -ctime $mtime)
		fi
	else
  		for str in ${string[@]}; do
			if !(( $LFIND )); then
				files=$(ls -1 $ALIEN_CACHE_DIR/*.{zst,xz} | grep $str)
				pkg="$pkg $(echo $files | grep $str)"
			else
				files=$(find $ALIEN_CACHE_DIR/*.{zst,xz} -type f -ctime $mtime | grep $str)
				pkg="$pkg $(echo $files | grep $str)"
			fi
		done
	fi

	arraypkg=($pkg)
	ntotalpkg=${#arraypkg[*]}
	log_success_msg2 "${red}(${ntotalpkg}) ${green}file(s) found."
	LFORCELOCAL=$LFORCE

#	for package in $ALIEN_CACHE_DIR/$*
	for package in $pkg
	do
#		echo
#		packagedir=${package%$EXT}
		packagedir=${package}
		file=${package}
		FULLDIR=$BUILDDIR/$packagedir
		((ncount++))

#	   pkgtar=$(echo $packagedir |sed 's/\// /g'|awk '{print $NF}'|sed 's/.pkg.tar\|.zst\|.xz//g'|sed 's/.pkg.tar\|.zst\|.xz//g'|sed 's/1://g'|sed 's/2://g')
		pkgtar=$(echo ${file##*/})                   #remove diretorio deixando somente nome do pacote
		pkgtar=$(echo ${pkgtar%%.pkg.tar.zst})       #remove .pkg.tar.zst
		pkgtar=$(echo ${pkgtar%%.pkg.tar.xz})        #remove .pkg.tar.xz

		cPacoteSemExt=$(echo ${pkgtar%%.*})          # https://elmord.org/blog/?entry=20121227-manipulando-strings-bash
		cPacoteSemExt=$(echo ${cPacoteSemExt%-*})    # https://elmord.org/blog/?entry=20121227-manipulando-strings-bash

		if !(( $LFORCELOCAL )); then
			local firstletter=${pkgtar::1}
#			local FilteredPackage=$(echo $pkgtar | sed 's/\(.*\)-/\1*/'|cut -d* -f1).chi.zst
			local FilteredPackage=$pkgtar.chi.zst
			local destpkgGIT="${GITDIR}/packages/${firstletter}/${FilteredPackage}"
			local destpkgCORE="${GITDIR}/packages/core/${FilteredPackage}"

			if [[ -e ${destpkgGIT} ]]; then
				log_failure_msg2 "(${ncount}/${ntotalpkg}) ${orange}${FilteredPackage} ${reset}Package already exist in ${green}${GITDIR}/packages/${firstletter/}${reset} Use the -f option to force rebuild."
				continue
			fi
			if [[ -e ${destpkgCORE} ]]; then
				log_failure_msg2 "(${ncount}/${ntotalpkg}) ${orange}${FilteredPackage} ${reset}Package already exist in ${green}${GITDIR}/packages/core/${reset} Use the -f option to force rebuild."
				continue
			fi
		fi

		destdir=$BUILDDIR/$pkgtar
		log_info_msg "(${ncount}/${ntotalpkg}) Creating directory $destdir"
		mkdir -p $destdir
		evaluate_retval

		log_info_msg "(${ncount}/${ntotalpkg}) Unpacking package $package at $destdir"
		tar --extract --file $package -C $destdir >/dev/null 2>&1
		evaluate_retval

		case $packagedir in
			luit-[0-9]* )
			sed -i -e "/D_XOPEN/s/5/6/" configure
			;;
		esac

#		CFG_FILE=$destdir/.PKGINFO
#		CFG_CONTENT=$(cat $CFG_FILE | sed -r '/[^=]+=[^=]+/!d' | sed -r 's/\s+=\s/=/g')
#		eval "$CFG_CONTENT"
#		info $CFG_CONTENT

#		while read var value
#		do
#		    export "$var" "$value"
#		done < $destdir/.PKGINFO

		sed -i 's/ = /="/g' $destdir/.PKGINFO  >/dev/null 2>&1
		sed -i 's/$/"/g' $destdir/.PKGINFO  >/dev/null 2>&1
		source "$destdir/.PKGINFO"

		export    ALIEN_DESC_BUILD="${pkgtar: -1}"
		export          DESC_BUILD="${pkgtar: -1}"
		export           ALIEN_URL="$url"
		export                 URL="$url"
		export       ALIEN_LICENSE="$license"
		export             LICENSE="$license"
		export          ALIEN_ARCH="$arch"
		export                ARCH="$arch"
		export          ALIEN_SIZE="$size"
		export                SIZE="$size"
		export          ALIEN_DESC="$pkgdesc"
		export                DESC="$pkgdesc"
		export           ALIEN_DEP="$depend"
		export                 DEP="$depend"
		export ALIEN_DESC_PACKNAME="$pkgname"
		export       DESC_PACKNAME="$pkgname"
		export ALIEN_DESC_VERSION=$( echo $pkgver|cut -d '-' -f1)
		export       DESC_VERSION=$( echo $pkgver|cut -d '-' -f1)
		export   ALIEN_DESC_BUILD=$( echo $pkgver|cut -d '-' -f2)
		export         DESC_BUILD=$( echo $pkgver|cut -d '-' -f2)
		export deps=$(cat $destdir/.PKGINFO | grep ^depend | awk -F'"' '{print $2}')


#	 	log_info_msg "Generating DESC for package at $destdir"
		pushd $destdir	>/dev/null 2>&1

#		as_root genalien $pkg >/dev/null 2>&1
#		sh_generatepkg $pkg $pkg
		mv $destdir/.BUILDINFO $destdir/info/ >/dev/null 2>&1
		mv $destdir/.MTREE     $destdir/info/ >/dev/null 2>&1
		mv $destdir/.PKGINFO   $destdir/info/ >/dev/null 2>&1
		mv $destdir/.INSTALL   $destdir/info/ >/dev/null 2>&1

#		rm -f $destdir/.BUILDINFO >/dev/null 2>&1
#		rm -f $destdir/.MTREE     >/dev/null 2>&1
#		rm -f $destdir/.PKGINFO   >/dev/null 2>&1

#		log_info_msg "Building $destdir package"
#		as_root bcpalien  >/dev/null 2>&1

		sh_createpkg $pkgtar $pkgtar -Y -F
		evaluate_retval

		sh_alienpkg_pkgsize
		popd >/dev/null 2>&1
		unset size

		removeoldpkgchili $cPacoteSemExt
		echo
	done
	unset ncount
	unset ntotalpkg
}

function sh_alienpkg_logo()
{
    _CAT << 'EOF'
       _ _                  _
  __ _| (_) ___ _ __  _ __ | | ____ _
 / _` | | |/ _ \ '_ \| '_ \| |/ / _` |
| (_| | | |  __/ | | | |_) |   < (_| |
 \__,_|_|_|\___|_| |_| .__/|_|\_\__, |
                     |_|        |___/
EOF
    sh_version
}


function sh_aliencheck()
{
	allfiles=$(ls -1 *.zst)

	for pkg in $allfiles
	do
		firstletter=${pkg::1}
	#	echo $firstletter
	#	FilteredPackage=$(echo $pkg | sed 's/\(.*\)-\(.*-\)/\1*\2/' |cut -d* -f1)
		FilteredPackage=$(echo $pkg | sed 's/\(.*\)-/\1*/'|cut -d* -f1).chi.zst

		destpkg="/github/ChiliOS/packages/${firstletter}/${FilteredPackage}"
		if [[ -e ${destpkg} ]]; then
			echo "file exist: ${destpkg}"
		fi
	done
}


function sh_alienpkg_main()
{
	sh_alienpkg_init
#	setvarcolors
#	sh_alienpkg_logo
#	sh_checkroot
	if [ $# -lt 1 ]; then
		echo "uso: $0 -a <package-alienigena-versao>"
		echo "     $0 alienpkg <package-alienigena-versao>"
		echo "     $0 --alienpkg <package-alienigena-versao>"
		echo "     $0 -a all"
	   exit 1
	fi
	sh_alienpkg_initvars $*
	sh_alienpkg_exec $*
}


function sh_upgrade()
{
	shift
	local param="$@"
	local LAUTO=$false
	local LFORCE=$false
	local LLIST=$false
	local count=0
	local s
	local item
	local cBaseInstalled cBaseVersionInstalled cVersionInstalled cBuildInstalled
	local	cBase cBaseVersion cVersion cBuild
	local ntotalinstalled
	local ntotalconfered
	local pkgrepo
	local ntotal_pkg_installed
	local ntotal_pkg_listed

	#sh_recreatefilepackagesinstalled

#	for s in ${param[@]}; do
#		[[ $(toupper "${s}") = "-Y" ]]  && { LAUTO=$true;  param[$count]=;}
#		[[ $(toupper "${s}") = "-F" ]]  && { LFORCE=$true; param[$count]=;}
#		[[ $(toupper "${s}") = "OFF" ]] && { LLIST=$false; param[$count]=;}
#		((count++))
#		[[ $(toupper "${s}") = "-Y" ]]  && LAUTO=$true
#		[[ $(toupper "${s}") = "-F" ]]  && LFORCE=$true
#		[[ $(toupper "${s}") = "OFF" ]] && LLIST=$false
#	done

	sh_listinstalled ${param} "OFF" "EXACT"

	local ntotal_pkg_installed=${public_ntotal_pkg_installed}
	local ntotal_pkg_listed=${public_ntotal_pkg_listed}

# info $pkginstalled

	for i in $pkginstalled; do
		sh_splitpkg "${i}"
		cBaseInstalled=${aPKGSPLIT[PKG_BASE]}
		cBaseVersionInstalled=${aPKGSPLIT[PKG_BASE_VERSION]}
		cVersionInstalled=${aPKGSPLIT[PKG_VERSION]}
		cBuildInstalled=${aPKGSPLIT[PKG_BUILD]}
#		pkgrepo=$(grep ^$cBaseInstalled $VARCACHE_SEARCH/packages)
		pkgrepo=$(grep ^$cBaseInstalled: $VARCACHE_SEARCH/packages-split | cut -d: -f4)
		count=0
		((ntotalconfered++))

		#debug

#info "pkginstalled: ${i}\npkgrepo: $pkgrepo"

		if [[ "${#pkgrepo}" -gt 0 ]]; then # pacote?
			for cPkg in ${pkgrepo}; do
				#debug
				#info $cPkg
				sh_splitpkg "${cPkg}"
				cBase=${aPKGSPLIT[PKG_BASE]}
				cBaseVersion=${aPKGSPLIT[PKG_BASE_VERSION]}
				cVersion=${aPKGSPLIT[PKG_VERSION]}
				cBuild=${aPKGSPLIT[PKG_BUILD]}

				case $cBase in
					Python) continue;;
					gtk+)   continue;;
				esac

#info "$cBaseInstalled == $cBase"

				if [[ $cBaseInstalled == $cBase ]]; then
					((count++))
					if [[ "$(vercmp $cBaseVersionInstalled $cBaseVersion)" -lt 0 ]]; then
						log_success_msg2 "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBase} ${reset}is being updated to newest version ($cVersion)."
						sh_doremove $cBaseVersionInstalled "OFF"
						sh_install "$cBaseVersion" "-y" "-f" "OFF"
					elif [[ "$cBaseVersionInstalled" = "$cBaseVersion" ]]; then
						if (( $LFORCE )); then
							sh_install "$cBaseVersion" "-y" "-f" "OFF"
							continue
						else
							log_success_msg2 "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBase} ${reset}is already the newest version ($cVersionInstalled). Use the -f option to force reinstallation."
							continue
						fi
					else
						if (( $LFORCE )); then
							sh_install "$cBaseVersion" "-y" "-f" "OFF"
						else
							log_success_msg2 "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBase} ${reset}is already the newest version ($cVersionInstalled)."
						fi
						if [ $count -gt 1 ]; then
							log_warning_msg "${orange}${cBaseInstalled} ${red}WARNING!! there is more than one release of the package in the repo!"
						fi
					fi
				else
   	 			log_warning_msg "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBase} ${reset}not installed."
				fi
			done
		else
			log_warning_msg "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBaseInstalled} ${red}WARNING!! package not in repo! Use 'fetch update' to update the database"
		fi
	done

	if [[ "${#pkginstalled}" -le 1 ]]; then # nenhum pacote?
		log_warning_msg "${orange}${@}${cyan} package not installed"
		echo
		conf "${blue}:: ${reset}Install Pakages(s)?"
		LAUTO=$?
		if (( $LAUTO )); then
			sh_search $param -y -f
		fi
	fi
	sh_cdroot
}


checkDependencies() {
  local errorFound=0

  for command in "${DEPENDENCIES[@]}"; do
    if ! which "$command"  &> /dev/null ; then
      echo "ERRO: não encontrei o comando '$command'" >&2
      errorFound=1
    fi
  done

  if [[ "$errorFound" != "0" ]]; then
    echo "---IMPOSSÍVEL CONTINUAR---"
    echo "Esse script precisa dos comandos listados acima" >&2
    echo "Instale-os e/ou verifique se estão no seu \$PATH" >&2
    exit 1
  fi
}


#figlet
function logo()
{
	_CAT << 'EOF'
  __      _       _
 / _| ___| |_ ___| |__           Copyright (C) 2019-2020 Vilmar Catafesta <vcatafesta@gmail.com>
| |_ / _ \ __/ __| '_ \
|  _|  __/ || (__| | | |         Este programa pode ser redistribuído livremente
|_|  \___|\__\___|_| |_|         sob os termos da Licença Pública Geral GNU.
EOF
	sh_version
}

setvarcolors

if [[ $1 = "-a" ]] || [[ $1 = "--alienpkg" ]] || [[ $1 = "alienpkg" ]]; then
	sh_alienpkg_logo
else
	logo
fi

if [[ $1 = "" ]] || [[ $1 = "-h" ]] || [[ $1 = "--help" ]] || [[ $1 = "help" ]] || [[ $1 = "-help" ]]; then
	help
fi

sh_checkroot
checkDependencies
init $*

# vim:set ts=3 sw=3 et:
