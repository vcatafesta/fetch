#!/usr/bin/env bash
#shellcheck disable=SC2034,SC2015,SC2154,SC2140,SC2016,SC2153,SC2068,SC2155
#shellcheck source=/dev/null

# 	fetch - search, install, create, remove, upgrade packages compatible with:
# 	Chili GNU/Linux - https://github.com/vcatafesta/ChiliOS
#	Chili GNU/Linux - https://chililinux.com
#	Chili GNU/Linux - https://chilios.com.br
# 	MazonOS GNU/Linux - http://mazonos.com
#
# 	Created: 2019/04/05
# 	Altered: 2023/04/29
#
# 	Copyright (c) 2019-2022, Vilmar Catafesta <vcatafesta@gmail.com>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# 	fetch uses quite a few external programs during its execution. You
# 	need to have at least the following installed for makepkg to function:
#  	awk, bsdtar (libarchive), bzip2, coreutils, fakeroot, file, find (findutils),
#   	gettext, gpg, grep, gzip, sed, tput (ncurses), xz
# 	contains portion of software https://bananapkg.github.io/
#########################################################################
#debug
export PS4='${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset} '
#set -x
#set -e
shopt -s extglob

# Import lib
readonly _VERSION_="3.40.20230429"
#LIBRARY=${LIBRARY:-'/usr/share/fetch'}
#[[ -f "${LIBRARY}/core.sh" ]] && source "${LIBRARY}/core.sh"
SYSCONFDIR=${SYSCONFDIR:-'/etc/fetch'}

# var bool
declare -i ERR_OK=0
declare -i ERR_ERROR=1
declare -i true=1
declare -i false=0
declare -i LINSTALLED=2

sh_setEnvironment() {
	sh_setvarcolors
	export LC_ALL=C
	export LANG=C
	readonly DEPENDENCIES=(which find tar zstd curl sed sort grep cat awk tput stat tee lynx numfmt)
	readonly BOOTLOG="/tmp/fetch-$(sh_diahora).log"
	readonly LOGGER='/dev/tty8'
	unset CDPATH
	unset GREP_OPTIONS

	[[ -s  "$SYSCONFDIR/fetch.conf" ]] || sh_touchconf
	[[ -s  "$SYSCONFDIR/fetch.conf" ]] && source "$SYSCONFDIR/fetch.conf" || return 1

	# files
   FOLDERS_METAPACKAGES='folders_metapackages.csv'
   METAPACKAGES='metapackages.csv'
   PACKAGES_SPLIT='packages-split.csv'
   PACKAGES_INSTALLED_SPLIT='packages-installed-split.csv'
   PACKAGES_IN_CACHE='packages-in-cache.csv'

	#var public
	declare -a public_pkg_not_found=()
	declare -a public_pkg=()
	declare -a public_pkg_deps=()
	declare -a public_ListSearch=()
	declare -i public_ntotal_pkg_installed=0
	declare -i public_ntotal_pkg_listed=0
	declare -i public_len_count_pkg=0

	# default
	export PKG_EXT SEP SITE GITSITE RAW APP
	export CACHEDIR CACHEDIR_ARCHIVES CACHEDIR_SEARCH
	export CACHEDIR_LIST CACHEDIR_DESC CACHEDIR_REMO
	export VARLIB_FETCH
	export DESCME
	export ALIEN_CACHE_DIR="${ALIEN_CACHE_DIR:=/var/cache/pacman/pkg}"
	export ALIEN_VARLIB="/var/lib/pacman/local"

	verbose=0
	SEP=','
	: "${PKG_EXT:='chi.zst'}" 	# se PKG_EXT não estiver definida, recebe 'chi.zst'
	: "${GITSITE:=0}"				# se GITSITE não estiver definida, recebe 0
	SITE="${PKG_SITE:=https://chililinux.com}"
	RAW="${PKG_RAW:=https://raw.githubusercontent.com/vcatafesta/ChiliOS/master}"
	APP="fetch"
	APP="${0##*/}"
	CACHEDIR="${CACHEDIR:=/var/cache/$APP}"
	CACHEDIR_ARCHIVES="$CACHEDIR/archives"
	CACHEDIR_SEARCH="$CACHEDIR/search"
	CACHEDIR_LIST="$CACHEDIR/list"
	CACHEDIR_DESC="$CACHEDIR/desc"
	CACHEDIR_REMO="$CACHEDIR/remove"
	DESCME='info/desc'
	VARLIB_FETCH="/var/lib/$APP"
	CHILI_OS=$true

	# flag's para split package
	: "${aPKGSPLIT=()}"
	: "${aPKGLIST=}"
	: "${PKG_FOLDER_DIR=0}"
	: "${PKG_FULLNAME=1}"
	: "${PKG_ARCH=2}"
	: "${PKG_BASE=3}"
	: "${PKG_BASE_VERSION=4}"
	: "${PKG_VERSION=5}"
	: "${PKG_BUILD=6}"

	if [[ -z "${COLUMNS}" ]]; then
      COLUMNS=$(stty size)
      COLUMNS=${COLUMNS##* }
   fi
   if [[ "${COLUMNS}" = "0" ]]; then
      COLUMNS=80
   fi
   COL=$((COLUMNS - 8))
   SET_COL="\\033[${COL}G" # at the $COL char
   CURS_ZERO="\\033[0G"

	#temporary
	TMP_DIR_ROOT="$(mktemp -d -u)"
	TMP_DIR_BACKUP="$TMP_DIR_ROOT/$APP/$CACHEDIR_SEARCH"
	TMP_DIR_FOLDERS="$TMP_DIR_ROOT/$APP/$CACHEDIR/folders"

	# regex's
	#DATE_RE='(\d{4}-\d{2}-\d{2}\s\d{2}:\d{2})'	#2022-03-16 14:22
	#RE_ALIEN='.+\.zst$|.+\.xz$' 						#VC
	#RE_ALIEN='.+\.[zst|xz]+$'  						#VC
	RE_ALIEN='.+\.(zst|xz)$'   						#Bagatini/Blau

	if [[ "$PKG_EXT" = "chi.zst" ]]; then
		CHILI_OS=$true
		#PKG_RE='^([a-z-]+)(-)([0-9\\.]+)(-)([0-9])(-)(.*)(.chi.zst)$'
		#PKG_RE='([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*)-(([0-9]+(\.[0-9]+)*)(-([0-9]+))?)-([^.]+).*'
		#PKG_RE='(.+)-(([^-]+)-([0-9]+))-([^.]+)\.chi\.zst' 				#SOEN
#		PKG_RE='(.+)-(([^-]+)-([0-9]+))-([^.]+)\.chi\.zst'    			#VC
		PKG_RE='(.+)-(([^-]+)-([0-9]+))-([^.]+)(\.chi\.zst)$'   			#VC
#		PKG_RE_LYNX='(?!.*\/)(.*)-(([^-]+)-([0-9]+))-([^.]+)(\.chi\.zst)$'
#		PKG_RE_FULL1='(?:")(.+)-(([^-]+)-([0-9]+))-([^.]+)\.chi\.zst(?="><a)'
#		PKG_RE_FULL2='(?:e">)(.+)-(([^-]+)-([0-9]+))-([^.]+)(\.chi)(\.zst)(?=<\/a)'
		GREP_RE='.chi\.zst\"'
		#SED_RE='^.+>(.+)-(([^-]+)-([0-9]+))-([^.]+)(.chi.zst)<.a>.*([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[A-z]{3}-[0-9]{4})[ ]([0-9]{2}:[0-9]{2}).*[ ]([0-9]+k?)(.*)'
		#SED_RE='^.+="(.+)-(([^-]+)-([0-9]+))-([^.]+)(.chi.zst)".+<.a>.*([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[A-z]{3}-[0-9]{4})[ ]([0-9]{2}:[0-9]{2}).+[ ]([0-9]+k?)(.*)'
		SED_RE='^.*["|\/](.+)-(([^-]+)-([0-9]+))-([^.]+)(.chi.zst)".+<.a>.*([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[A-z]{3}-[0-9]{4})[ ]([0-9]{2}:[0-9]{2}).+[ ]([0-9]+k?).*'
#		FETCH_RE='-[^a-z]+?[^-]+-[0-9].*-'
#		FETCH_RE='-[^-]+-[0-9]-'
#		FETCH_RE='-[^-]+[0-9]+-[^.]+.chi.*'
#		FETCH_RE='-[^-]+[0-9]+[^.]*\.chi[^.]*\.zst'
#		FETCH_RE='-[^-]+[0-9]+[^.]*.chi[^.]*.zst'
		FETCH_RE='-[0-9]+(\\.[0-9]+)*-[0-9]+'
	else
		CHILI_OS=$false
		#PKG_RE='(.+)-(([^-]+)-([0-9]+))\.mz' 						#SOEN
		PKG_RE='(.+)-(([^-]+)-([0-9]))\.mz' 						#VC
#		PKG_RE_LYNX='(?!.*\/)(.+)-(([^-]+)-([0-9]))\.mz$'		#VC
		GREP_RE='.mz\"'
#		SED_RE='^.+href="(.+)-(([^-]+)-([0-9]))()(\.mz\b)".+([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[A-z]{3}-[0-9]{4})[ ]([0-9]{2}:[0-9]{2})[ ]+([0-9]+[.]?[0-9]+.?).+'
		SED_RE='^.+href="(.+)-(([^-]+)-([0-9]))()(\.mz\b)".+([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[A-z]{3}-[0-9]{4})[ ]([0-9]{2}:[0-9]{2})[ ]+([0-9]?[.]?[0-9]?.?).+'
#		SED_RE='^.+href="(.+)-(([^-]+)-([0-9]))()(\.mz\b)".+([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[A-z]{3}-[0-9]{4})[ ]([0-9]{2}:[0-9]{2})[ ]+([0-9.])+([BKMGT]?)\b'
#		SED_RE='^.+href="(.+)-(([^-]+)-([0-9]))()(\.mz\b)".+([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[A-z]{3}-[0-9]{4})[ ]([0-9]{2}:[0-9]{2})[ ]+([0-9.]+)+([BKMGT])?'
		SED_RE='^.+href="(.+)-(([^-]+)-([0-9]))()(\.mz\b)".+([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[A-z]{3}-[0-9]{4})[ ]([0-9]{2}:[0-9]{2})[ ]+(([0-9]+)([BKMGT]?)).+'
		FETCH_RE='-[^-]+-[0-9]+[.]'
	fi
}

###########################################################################################################################################################################################################
function toupper()               { declare -u TOUPPER=${*}; echo -e "${TOUPPER}"; }
function tolower()               { declare -l TOLOWER=${*}; echo -e "${TOLOWER}"; }
function toupperA()              { tr '[:lower:]' '[:upper:]' <<< "$1"; }
function tolowerA()              { tr '[:upper:]' '[:lower:]' <<< "$1"; }
function sh_linecount() 			{ awk 'END {print NR}' "$1"; }
function strzero()					{ printf "%0*d" "$2" "$1"; }
function arraylen() 					{ local new=("$@"); echo "${#new[*]}"; }
function DOT()							{ printf "%s" "${blue}:: ${reset}"; return; }
function info_msg()					{ printf "%s" "\033[1m$*\n\033[m"; }
function sizeof_du()             { du -bs $1 | cut -f1; }

function lenarray() {
	sh_linecount <<< "$(printf "%s\n" "$*")"
}

function sh_diahora() {
	DIAHORA=$(date +"%d%m%Y-%T" | sed 's/://g')
	printf "%s\n" "$DIAHORA"
}

function fmtplus() {
	printf "${bold}${yellow}%03d/%03d${reset}" "$ncounter" "$ncounter"
	return $?
}

function fmt() {
	printf "%s" "${pink}(${ncount}:5/${ntotalpkg}:${nfullpkg})${reset}"
	return $?
}

function print() {
	[[ "$printyeah" = '1' ]] && echo -e "$@"
}

function conf() {
	read -p "$1 [Y/n]"
	[[ ${REPLY^} == "" ]] && return $true
	[[ ${REPLY^} == N ]]  && return $false || return $true
}

function readconf() {
	if [[ $LC_DEFAULT -eq 0 ]]; then
		read -r -p "$@ [S/n]"
	else
		read -r -p "$@ [Y/n]"
	fi
	[[ ${REPLY^} == "" ]]  && return 0
	[[ ${REPLY^} == N  ]]  && return 1 || return 0
}

function confok() {
	read -p "$1 [Y/n]"
	[[ ${REPLY^} == "" ]] && return $true
	[[ ${REPLY^} == N ]] && return $false || return $true
}

function confno() {
	read -p "$1 [N/y]"
	[[ ${REPLY^} == "" ]] && return 0
	[[ ${REPLY^} == N  ]] && return 0 || return 1
}

function die() {
	if test $# -ge 2; then
		evaluate_retval 1
	fi
	local msg=$1; shift
	printf "%-75s\n" "$(DOT)${bold}${red}$msg${reset}" >&2
	exit 1
}

sh_setLogPrefix() {
   COL_NC='\e[0m' # No Color
   COL_LIGHT_GREEN='\e[1;32m'
   COL_LIGHT_RED='\e[1;31m'
   TICK="${white}[${COL_LIGHT_GREEN}✓${COL_NC}${white}]"
   CROSS="${white}[${COL_LIGHT_RED}✗${COL_NC}${white}]"
   INFO="[i]"
   # shellcheck disable=SC2034
   DONE="${COL_LIGHT_GREEN} done!${COL_NC}"
   OVER="\\r\\033[K"
   NORMAL="${reset}"
   SUCCESS="${green}"
   WARNING="${yellow}"
   FAILURE="${red}"
   INFO="${cyan}"
   BRACKET="${blue}"
   BMPREFIX="     "
   DOTPREFIX="  ${blue}::${reset} "
#  SUCCESS_PREFIX="${SUCCESS}  ↑  ${NORMAL}"
   SUCCESS_PREFIX=" $TICK "
   SUCCESS_SUFFIX="${BRACKET}[${SUCCESS}  OK  ${BRACKET}]${NORMAL}"
#  FAILURE_PREFIX="${FAILURE}  ↓  ${NORMAL}"
   FAILURE_PREFIX=" $CROSS "
   FAILURE_SUFFIX="${BRACKET}[${FAILURE} FAIL ${BRACKET}]${NORMAL}"
   WARNING_PREFIX="${WARNING}  W  ${NORMAL}"
   WARNING_SUFFIX="${BRACKET}[${WARNING} WARN ${BRACKET}]${NORMAL}"
   SKIP_PREFIX="${INFO}  S  ${NORMAL}"
   SKIP_SUFFIX="${BRACKET}[${INFO} SKIP ${BRACKET}]${NORMAL}"
   WAIT_PREFIX="${WARNING}  R  ${NORMAL}"
   WAIT_SUFFIX="${BRACKET}[${WARNING} WAIT ${BRACKET}]${NORMAL}"
}

function replicate() {
	local Var
	printf -v Var %"$2s" " "
	echo "${Var// /$1}"
}

function timespec() {
	STAMP="$(date +"%b %d %T %:z") $(hostname)"
	echo "$STAMP"
	return 0
}

function unfmt() {
	local last_msg="$*"
	logmessage="${last_msg/${bold}${yellow}/}"
	logmessage="${logmessage/${reset}/}"
	echo "$logmessage"
}

function log_info_msg() {
	last_msg="$*"

	if ! (( quiet )); then
		echo -n -e "${BMPREFIX}${*}"
	fi
	return 0
}

function log_wait_msg() {
	printf "${BMPREFIX}${*}"
	printf "${CURS_ZERO}${WAIT_PREFIX}${SET_COL}${WAIT_SUFFIX}\n"
	return 0
}

evaluate_retval() {
   local error_value="$?"
   local error_fatal="$2"
   local cmsgdie="$3"

   [[ -z "$error_fatal" ]] && error_fatal=$true

   if [[ $# -gt 0 ]]; then
      error_value="$1"
   fi

   if [[ "${error_value}" = 0 ]]; then
      log_success_msg ''
   else
      log_failure_msg ''
   fi

   if (( error_value )) ; then
      if (( error_fatal )) ; then
         [[ -z "$cmsgdie" ]] && die "${cmsg_InstalacaoAbortada[$LC_DEFAULT]}..." || die "$cmsgdie"
      else
         log_error "${cmsg_Error_not_fatal[LC_DEFAULT]} $BOOTLOG"
      fi
   fi
   return "${error_value}"
}

log_failure_msg() {
   if (( verbose )); then
		echo -n -e "${BMPREFIX}${*}"
		echo    -e  "${CURS_ZERO}${FAILURE_PREFIX}${SET_COL}${FAILURE_SUFFIX}"
	fi
	logmessage=${last_msg/$bold$red$green$yellow/}
	printf "%s\n" "$(timespec) [ FAIL ]${logmessage}" 2>&1 | tee -i -a "$BOOTLOG" >"$LOGGER"
	replicate "#" "100" | tee -i -a "$BOOTLOG" >"$LOGGER"
	return 0
}

function log_failure_msg2() {
	printf "%s"		"${BMPREFIX}${*}"
	printf "%s\n"	"${CURS_ZERO}${FAILURE_PREFIX}${SET_COL}${FAILURE_SUFFIX}"
	return 0
}

log_success_msg() {
   if (( verbose )); then
      echo -n -e "${BMPREFIX}${*}"
      echo    -e "${CURS_ZERO}${SUCCESS_PREFIX}${SET_COL}${SUCCESS_SUFFIX}"
   fi
   logmessage=$(unfmt "$last_msg")
   printf "%s\n" "$(timespec) [  OK  ]${logmessage}" 2>&1 | tee -i -a "$BOOTLOG" >"$LOGGER"
   replicate "#" "100" | tee -i -a "$BOOTLOG" >"$LOGGER"
   return 0
}

function log_success_msg2() {
	printf "%s" 	"${BMPREFIX}${*}"
	printf "%s\n"	"${CURS_ZERO}${SUCCESS_PREFIX}${SET_COL}${SUCCESS_SUFFIX}"
	return 0
}

function sh_adel() {
	local arr=("$@")
	local new=()
	local nfiles="${#arr[*]}"

	if (( nfiles )); then
#		new=($(uniq -u <<< "$(printf '%s\n' "${arr[@]}")"))
		mapfile -t new <<< "$(uniq -u <<< "$(printf '%s\n' "${arr[@]}")")"
	fi
	printf '%s\n' "${new[@]}"
	return 0
}

function debug() {
   whiptail	                  \
      --fb                    \
      --clear                 \
      --backtitle "[debug]$0" \
      --title     "[debug]$0" \
      --yesno     "${*}\n" \
   0 40
   result=$?
   if (( result )); then
      exit
   fi
   return $result
}

function info() {
	dialog                     \
	--backtitle "\n$*\n"       \
	--title     "[info]$0"     \
   --yesno     "${*}\n"       \
   0 0
   result=$?
   if (( result )); then
      exit
   fi
   return $result
}

function sh_checkroot() {
	local str="root user check"
   if [[ "$(id -u)" != "0" ]]; then
		(( verbose >= 2 )) && log_msg $true "${str} - $USER"
      die "${red} error: you cannot perform this operation unless you are root."
   fi
	(( verbose >= 2 )) && log_msg $false "${str}"
   return 0
}

function sh_toBytes() {
   local ent mut num fra sai

   ent=${1^^}
   [[ $ent = "" || $ent = '0' ]] && ent=0B
   mut=${ent//[^BKMGT]}
   num=${ent//[^[:digit:]]}
   ent=${ent//$mut}
   fra=${ent//[^,.]}
   fra=${fra:+${ent//*[,.]}}
   ent=0BKMGT;
   ent=${ent//$mut*};
   #mut=$((${#ent}-1))
   ((mut=${#ent}-1, sai=num*1024**mut))
   ((ent=${#sai}-${#fra}))
   echo ${sai:0:$ent}
}

function human_to_bytes() {
	local size="$1"
	[[ -z "$size" ]] && size="0"
	local lastletter=${size:0-1}
	local count=0
	local upper=${lastletter^^}

	size=${size/$lastletter/$upper}
	LC_ALL=C numfmt --from=iec "$size"
	return "$?"
}

function human_to_size() {
	human_to_bytes "$1"
	return "$?"
}

function size_to_human() {
	local size="$1"
	[[ -z "$size" ]] && size="0"
	LC_ALL=C numfmt --to=si "$size"
	return "$?"
}

function log_msg() {
	local retval="${PIPESTATUS[0]}"
	local pcount=$#

	(( pcount >= 2 )) && { retval=$1; shift; }
	if [[ $retval -eq 0 ]]; then
		printf " %b %s\\n" "${TICK}" "${*}"
	else
		printf " %b %s\\n" "${CROSS}" "${*}"
	fi
}

function sh_setvarcolors() {
	if tput setaf 1 &> /dev/null; then
		#tput sgr0; # reset colors
      bold=$(tput bold);
      reset=$(tput sgr0);
      rst=$(tput sgr0);
      rs=$(tput sgr0);
      blue=$(tput setaf 33);
      cyan=$(tput setaf 37);
      green=$(tput setaf 2);
      orange=$(tput setaf 166);
      purple=$(tput setaf 125);
      violet=$(tput setaf 61);
		red=$(tput bold)$(tput setaf 196)
      yellow=$(tput bold)$(tput setaf 3)
      pink=$(tput setaf 129);
		black="${bold}$(tput setaf 0)"
		white="${bold}$(tput setaf 7)"
   else
      bold='';
      reset="\e[0m";
      rst="\e[0m";
      rs="\e[0m";
      reset="\e[0m";
      blue="\e[1;34m";
      cyan="\e[1;36m";
      green="\e[1;32m";
      orange="\e[1;33m";
      purple="\e[1;35m";
      red="\e[1;31m";
      violet="\e[1;35m";
      white="\e[1;37m";
      yellow="\e[1;33m";
      pink="\033[35;1m";
      black="\e[1;30m";
   fi
}

function sh_unsetvarcolors() {
	unset bold reset rst rs blue cyan green orange
	unset purple red violet white yellow pink black
}

function sh_touchconf() {
	[[ -d "${SYSCONFDIR}" ]] || mkdir -p "${SYSCONFDIR}" >/dev/null 2>&-
	cat > "$SYSCONFDIR/fetch.conf" <<-'_EOF_'
######################################################################
# Generated with fetch    - https://chililinux.com
# fetch.conf
######################################################################
# extension of packages: chili=chi.zst, mazonos=mz
#PKG_EXT='mz'			# http://mazonos.com
PKG_EXT='chi.zst'		# https://chililinux.com | https://chilios.com.br | https://github.com/vcatafesta/ChiliOS

# packages hosted on GITHUB repository: yes='1', not='0'
GITSITE='0'

# distro hosting website/packages
#PKG_SITE='https://github.com/vcatafesta/ChiliOS/tree/master'		# for use set GITSITE=1
PKG_SITE='https://chililinux.com'					    					# for use set GITSITE=0
#PKG_SITE='https://chilios.com.br'											# for use set GITSITE=0
#PKG_SITE='https://chililinux.org'					     					# for use set GITSITE=0
#PKG_SITE='http://localhost'													# for use set GITSITE=0
#PKG_SITE='http://mazonos.com'												# for use set GITSITE=0

#not needed change
PKG_RAW='https://raw.githubusercontent.com/vcatafesta/ChiliOS/master'

# configuration for generation new packages
MAINTAINER='Vilmar Catafesta <vcatafesta@gmail.com>'
GPG_SIGN='0'
REWRITE_SIGN='1'
CREATE_SHA256='0'
DESC_BUILD='1'
URL='https://www.linuxfromscratch.org/lfs/view/stable/'
LICENSE='GPL2'
LFS_VERSION='11.3'
LFS_INIT='SYSTEMD'
ARCH='x86_64'
DISTRO='chili'
LOCALDIR='/github/ChiliOS'
PKGCORE="$LOCALDIR/packages/core"
CACHEDIR='/var/cache/fetch'
ALIEN_CACHE_DIR='/var/cache/pacman/pkg'
IGNOREPKG=('glibc' 'file')

#end
_EOF_
}

function clinesplit() {
	printf 	"%s%s%s%s%s%s%s%s"							\
				"${aPKGSPLIT[$PKG_BASE]}$SEP"				\
				"${aPKGSPLIT[$PKG_VERSION]}$SEP"			\
				"${aPKGSPLIT[$PKG_BUILD]}$SEP"			\
				"${aPKGSPLIT[$PKG_FULLNAME]}$SEP"		\
				"${aPKGSPLIT[$PKG_PKG_FOLDER_DIR]}/${aPKGSPLIT[$PKG_FULLNAME]}$SEP" \
				"${aPKGSPLIT[$PKG_BASE_VERSION]}$SEP"	\
				"${aPKGSPLIT[$PKG_SIZE]}$SEP"				\
				"${aPKGSPLIT[$PKG_FOLDER_DIR]}"
}

function clineascan() {
	printf "%s\n" "${aPKGARRAY[0]}$SEP${aPKGARRAY[1]}$SEP${aPKGARRAY[2]}$SEP${aPKGARRAY[3]}$SEP${aPKGARRAY[4]}$SEP${aPKGARRAY[5]}$SEP${aPKGARRAY[6]}"
}

function clineinstallascan() {
	printf "%s" "${aPKGARRAY[5]}  $(size_to_human "${aPKGARRAY[6]}")"
}

function sh_arraypkgfullVET() {
	OLDIFS=$IFS
	local file_list_packages="$1"
   [[ $# -eq 0 ]] && file_list_packages="$CACHEDIR_SEARCH/$PACKAGES_SPLIT"

	public_len_count_pkg=0

   declare -a public_pkg_base
   declare -a public_pkg_version
   declare -a public_pkg_build
   declare -a public_pkg_fullname
   declare -a public_pkg_dirfullname
   declare -a public_pkg_base_version
   declare -a public_pkg_size
   declare -a public_pkg_site
   local ind=0

	(( verbose >= 2 )) && log_msg "Checking packages"

	while IFS=, read -r	 	public_pkg_base[$ind] \
									public_pkg_version[$ind] \
									public_pkg_build[$ind]	\
									public_pkg_fullname[$ind] \
									public_pkg_dirfullname[$ind] \
									public_pkg_base_version[$ind]\
	   							public_pkg_size[$ind] \
	   							public_pkg_site[$ind]
	   do
	   	((ind++))
	done < "$file_list_packages"
	public_len_count_pkg=${#public_pkg_base[*]}
	IFS=$OLDIFS
	return 0
}

function sh_arraypkgfullIFS() {
	OLDIFS=$IFS
	local file_list_packages="$1"
   [[ $# -eq 0 ]] && file_list_packages="$CACHEDIR_SEARCH/$PACKAGES_SPLIT"

	public_len_count_pkg=0
   export public_pkg_base
   export public_pkg_version
   export public_pkg_build
   export public_pkg_fullname
   export public_pkg_dirfullname
   export public_pkg_base_version
   export public_pkg_size
   export public_pkg_site

	(( verbose >= 2 )) && log_msg "Checking packages"

	while IFS=, read -r fld1 fld2 fld3 fld4 fld5 fld6 fld7 fld8; do
	   public_pkg_base+=("${fld1}")
	   public_pkg_version+=("${fld2}")
	   public_pkg_build+=("${fld3}")
	   public_pkg_fullname+=("${fld4}")
	   public_pkg_dirfullname+=("${fld5}")
	   public_pkg_base_version+=("${fld6}")
	   public_pkg_size+=("${fld7}")
	   public_pkg_site+=("${fld8}")
	done < "$file_list_packages"

	public_len_count_pkg=${#public_pkg_base[*]}
	IFS=$OLDIFS
	return 0
}

function sh_arraypkgfull() {
	local file_list_packages="$1"
   [[ $# -eq 0 ]] && file_list_packages="$CACHEDIR_SEARCH/$PACKAGES_SPLIT"
	(( verbose >= 2 )) && log_msg "Checking packages"

#	public_pkg_base=($(        awk -F"$SEP" '{ print $1 }' "$file_list_packages"))
#	public_pkg_version=($(     awk -F"$SEP" '{ print $2 }' "$file_list_packages"))
#	public_pkg_build=($(       awk -F"$SEP" '{ print $3 }' "$file_list_packages"))
#	public_pkg_fullname=($(    awk -F"$SEP" '{ print $4 }' "$file_list_packages"))
#	public_pkg_dirfullname=($( awk -F"$SEP" '{ print $5 }' "$file_list_packages"))
#	public_pkg_base_version=($(awk -F"$SEP" '{ print $6 }' "$file_list_packages"))
#	public_pkg_size=($(        awk -F"$SEP" '{ print $7 }' "$file_list_packages"))
#	public_pkg_site=($(        awk -F"$SEP" '{ print $8 }' "$file_list_packages"))

	mapfile -t public_pkg_base				<<< "$(awk -F"$SEP" '{ print $1 }' "$file_list_packages")"
	mapfile -t public_pkg_version			<<< "$(awk -F"$SEP" '{ print $2 }' "$file_list_packages")"
	mapfile -t public_pkg_build			<<< "$(awk -F"$SEP" '{ print $3 }' "$file_list_packages")"
	mapfile -t public_pkg_fullname		<<< "$(awk -F"$SEP" '{ print $4 }' "$file_list_packages")"
	mapfile -t public_pkg_dirfullname	<<< "$(awk -F"$SEP" '{ print $5 }' "$file_list_packages")"
	mapfile -t public_pkg_base_version	<<< "$(awk -F"$SEP" '{ print $6 }' "$file_list_packages")"
	mapfile -t public_pkg_size				<<< "$(awk -F"$SEP" '{ print $7 }' "$file_list_packages")"
	mapfile -t public_pkg_site 			<<< "$(awk -F"$SEP" '{ print $8 }' "$file_list_packages")"

	public_len_count_pkg="${#public_pkg_base[*]}"
	return 0
}

function callback() {
	local IFS=,
	eval linha"$1="\("$2"\)
}

function sh_arraypkgfullMapfile() {
	local acampo=()
	local file_list_packages=$1
   [[ $# -eq 0 ]] && file_list_packages="$CACHEDIR_SEARCH/$PACKAGES_SPLIT"
	public_len_count_pkg=0

	(( verbose >= 2 )) && log_msg "Checking packages"
#	foo() { echo "|$2|"; }; mapfile -t -d, -n7 -c1 -C 'foo' <"$file_list_packages"
#	public_pkg_base=${public_pkg_base[@]//,*}

#	callback() {
#		local IFS=,
#		eval linha$1=\($2\)
#	}
	mapfile -t -c1 -C callback < "$file_list_packages"
	#declare -p linha{0..2}
	#L=1;	C=4; eval echo "\${linha$L[C]}"

	acampo=(base version build fullname dirfullname base_version size site)

	for i in {0..5386}; {
		for j in ${!acampo[*]}; {
			eval public_pkg_"${acampo[j]}"+=\("\${linha${i}[j]}"\)
		}
	}

#	for i in {0..5386}
#	do
#		#  eval echo "\${linha$i[6]}"
#		#  eval val="\${linha$i[6]}"
#		#  pkg_size+=("$val")
#		eval public_pkg_base+=("\${linha$i[0]}")
#		eval public_pkg_version+=("\${linha$i[1]}")
#		eval public_pkg_build+=("\${linha$i[2]}")
#		eval public_pkg_fullname+=("\${linha$i[3]}")
#		eval public_pkg_dirfullname+=("\${linha$i[4]}")
#		eval public_pkg_base_version+=("\${linha$i[5]}")
#		eval public_pkg_size+=("\${linha$i[6]}")
#		eval public_pkg_site+=("\${linha$i[7]}")
#	done

	public_len_count_pkg=${#public_pkg_base[*]}
	return 0
}

function sh_ascanpkg() {
#	local pkgsearch="^$1$"
	local pkgsearch="$1"
	local pos="$2"
	local indice
	local d
	aPKGARRAY=()

	indice=$(awk -F"$SEP"   -v var="^$pkgsearch$" -v field=$((++pos)) '$field ~ var { print NR}' "$CACHEDIR_SEARCH/$PACKAGES_SPLIT")
#	case $pos in
#		0) indice=$(awk -F$SEP -v var="$pkgsearch" -v field=1 '$'"field"' ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
#		0) indice=$(awk -F$SEP -v var="$pkgsearch" -v field=$((++pos)) '$field ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
#		0) indice=$(awk -F$SEP -v var="$pkgsearch" '$1 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
#		1) indice=$(awk -F$SEP -v var="$pkgsearch" '$2 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
#		2) indice=$(awk -F$SEP -v var="$pkgsearch" '$3 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
#		3) indice=$(awk -F$SEP -v var="$pkgsearch" '$4 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
#		4) indice=$(awk -F$SEP -v var="$pkgsearch" '$5 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
#		5) indice=$(awk -F$SEP -v var="$pkgsearch" '$6 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
#		6) indice=$(awk -F$SEP -v var="$pkgsearch" '$7 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
#		7) indice=$(awk -F$SEP -v var="$pkgsearch" '$8 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
#	esac

	if [[ -z $indice || "${indice//[0-9]/}" != "" ]]; then
		return 1
	fi

	#indice=$(printf "%d %d %d %d %d" "$indice") # corrigir bug do retorno do indice pelo awk quando varios pacotes mesmo nome
	indice=${indice%% *}
	((--indice))

	aPKGARRAY=(	"${public_pkg_base[$indice]}"
					"${public_pkg_version[$indice]}"
					"${public_pkg_build[$indice]}"
					"${public_pkg_fullname[$indice]}"
					"${public_pkg_dirfullname[$indice]}"
					"${public_pkg_base_version[$indice]}"
					"${public_pkg_size[$indice]}"
					"${public_pkg_site[$indice]}"
					)
	strstatus=''
	if grep -q ^"$pkgsearch$SEP" "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"; then
		strstatus='[installed]'
	fi
	return 0
}

function sh_ascanpkgGrep() {
	local pkgsearch="$1"
	local pos="$2"
	local indice=0
	aPKGARRAY=()

	case $pos in
		0) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<< "$(printf '%s\n' "${public_pkg_base[@]}")");;
		1) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<< "$(printf '%s\n' "${public_pkg_version[@]}")");;
		2) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<< "$(printf '%s\n' "${public_pkg_build[@]}")");;
		3) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<< "$(printf '%s\n' "${public_pkg_fullname[@]}")");;
		4) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<< "$(printf '%s\n' "${public_pkg_dirfullname[@]}")");;
		5) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<< "$(printf '%s\n' "${public_pkg_base_version[@]}")");;
		6) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<< "$(printf '%s\n' "${public_pkg_size[@]}")");;
		7) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<< "$(printf '%s\n' "${public_pkg_site[@]}")");;
	esac

	if [[ -z $indice ]]; then
		return 1
	fi
	indice="${indice%%:*}"
	((--indice))
	aPKGARRAY=(	"${public_pkg_base[$indice]}"
					"${public_pkg_version[$indice]}"
					"${public_pkg_build[$indice]}"
					"${public_pkg_fullname[$indice]}"
					"${public_pkg_dirfullname[$indice]}"
					"${public_pkg_base_version[$indice]}"
					"${public_pkg_size[$indice]}"
					"${public_pkg_site[$indice]}"
					)
	return 0
}

function sh_ascanpkgGrep2() {
	local pkgsearch="$1"
	local pos="$2"
	local indice=0
	aPKGARRAY=()

	case $pos in
		0)	indice=$( printf "%s\n" "${public_pkg_base[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1 );;
		1)	indice=$( printf "%s\n" "${public_pkg_version[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1 );;
		2)	indice=$( printf "%s\n" "${public_pkg_build[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1 );;
		3)	indice=$( printf "%s\n" "${public_pkg_fullname[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1 );;
		4)	indice=$( printf "%s\n" "${public_pkg_dirfullname[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1 );;
		5)	indice=$( printf "%s\n" "${public_pkg_base_version[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1 );;
		6)	indice=$( printf "%s\n" "${public_pkg_size[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1 );;
		7)	indice=$( printf "%s\n" "${public_pkg_site[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1 );;
	esac

	if [[ -z $indice ]]; then
		return 1
	fi

	((--indice))
	aPKGARRAY=(	"${public_pkg_base[$indice]}"
					"${public_pkg_version[$indice]}"
					"${public_pkg_build[$indice]}"
					"${public_pkg_fullname[$indice]}"
					"${public_pkg_dirfullname[$indice]}"
					"${public_pkg_base_version[$indice]}"
					"${public_pkg_size[$indice]}"
					"${public_pkg_site[$indice]}"
					)
	return 0
}

function sh_cabec() {
	printf "(${pink}%04d)${green} sts package%47sversion%8s%11ssize fullbasename\n" "$1"
}

function sh_write() {
	local pkgsearch="$1"
	local pos="$2"
	local pkgCheckNumber="$3"
   local status="$4"
   local clisting="$5"
	local strstatus=''
   local LSCAN=$true

   [[ "$pos"      = '-1' ]] && LSCAN=$false
	(( LSCAN )) && sh_ascanpkg "$pkgsearch" "$pos"
   [[ -z "$status"       ]] && status=' A '
	[[ "$clisting" == 'N' ]] && return 0
	[[ "$status" = ' I '  ]] && strstatus='installed'

	if (( verbose >= 2)); then
		if grep -q ^"$pkgsearch$SEP" "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"; then
			strstatus='installed'
			[[ "$status" != 'dep'  ]] && status=' I '
		else
			strstatus='         '
			[[ "$status" != 'dep'  ]] && status=' N '
		fi

		if [[ "$status" = 'dep' ]]; then
			if ! (( LDEPS )); then
				return
			fi
		fi

		printf "${green}%s(%04d) ${cyan}%-3s ${orange}%-43s$cyan $strstatus ${reset}%-15s${red}%15s ${reset}%s\n"	\
				 ""		 																															\
				 "$pkgCheckNumber" 																												\
				 "$status"	   																													\
				 "${aPKGARRAY[0]}"																												\
			 	 "${aPKGARRAY[1]}"																												\
			 	 "$(size_to_human "${aPKGARRAY[6]}")"			 																			\
		 	 	 "${aPKGARRAY[3]}"
	else
 		log_msg "[$pkgCheckNumber]${orange}${aPKGARRAY[0]}" # resumido
 	fi
	return 0
}

function sh_footer() {
	local pkgCheckNumber=$1
	log_msg "${green}($pkgCheckNumber)${reset} package(s) found."
}

# -La
function sh_list() {
	local param="$*"
	local nfiles
	local s x y
	local status=' A '
	local	SEARCH_CUT='-f1'
	local pkg
	local aout
	local	cListSearch

	LLIST=$true
	(( verbose >= 2 )) && log_msg "Reading package lists in the repository"
	if (( $# )); then
		for s in "${param[@]}"; do
			cListSearch+="$s "
		done
	fi

	if [[ -z "$cListSearch" ]]; then
#		if (( LALL )); then
# 			pkg="${public_pkg_base[@]}"
# 			aout="${public_pkg_base_version[@]}"
 			pkg=("${public_pkg_base[@]}")
 			aout=("${public_pkg_base_version[@]}")
#		else
#			log_msg $ERR_ERROR "${red}error${reset}: nenhum alvo definido (use -h para obter ajuda)"
#			return 1
#		fi
	else
		for x in ${cListSearch}; do
			(( LEXACT )) && y="^$x$SEP" || y="$x"
			if tmp=$(grep "$y" "$CACHEDIR_SEARCH/$PACKAGES_SPLIT");
			then pkg+=("$(cut -d"$SEP" -f1 <<< "$tmp")); aout+=($(cut -d"$SEP" -f5 <<< "$tmp")");
			else log_msg $ERR_ERROR "${red}error${reset}: alvo não encontrado: $x";
			fi
		done
	fi

	if ! nfiles=$(arraylen "${pkg[@]}" ); then
		return 1
	fi

	sh_writetable "${pkg[*]}" '0' "$nfiles"
	return $?
}

# -Li
function sh_listinstalled() {
	local param="$*"

	(( verbose >= 2 )) && log_msg "Listing installed packages"
	LLIST=$true
	LDEPS=$false
	SPLITPOS='0'

	[[ -z "${param}" ]] && LALL=$true || LALL=$false
	sh_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" "$param"
}

# -Li
function sh_listpkgdisp() {
	local file_list_package="$1"; shift
	local file_list_installed="$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
	local param="$*"
	local s
	local i
	local SEARCH_CUT="-f5"
	local nstatus=0
	local pgk_grep
	local ncontapkg=0
	local aBidi=()

	[[ -e $file_list_installed ]] || printf '' > "${file_list_installed}"

	#TODO: verificar necessidade
	#sh_arraypkgfull "$file_list_package"
	#TODO: verificar necessidade

	public_ntotal_pkg_installed=$(sh_linecount "$file_list_installed")
	public_ntotal_pkg_listed=$public_ntotal_pkg_installed
	public_pkg=()
	public_pkg_deps=()
	public_ListSearch=("$param")
	public_pkg_not_found=()

	if [[ -z "$SPLITPOS"       ]]; then
      SPLITPOS='4'
      SEARCH_CUT='-f5'
      AWK_CUT='$5'
   elif [[ "$SPLITPOS" == "0" ]]; then
      SEARCH_CUT='-f1'
      AWK_CUT='$1'
   elif [[ "$SPLITPOS" == "4" ]]; then
      SEARCH_CUT='-f5'
      AWK_CUT='$5'
   elif [[ "$SPLITPOS" == "5" ]]; then
      SEARCH_CUT='-f6'
      AWK_CUT='$6'
   fi

	if (( LALL )) || [[ -z "$param" ]]; then
		if (( LALL )); then
			mapfile -t public_pkg < <(awk -F$SEP '{print '"$AWK_CUT"'}' "$file_list_package")
		else
			die "${red}error${reset}: nenhum alvo definido (use -h para obter ajuda)"
		fi
	else
		for x in ${public_ListSearch[@]}; do
			if (( LEXACT )); then
				pkg_grep=$(grep ^"$x$SEP" "$file_list_package" | cut -d"$SEP" "$SEARCH_CUT")
			else
				pkg_grep=$(grep "$x" "$file_list_package" | cut -d"$SEP" "$SEARCH_CUT")
			fi

			if [[ -n "$pkg_grep" ]]; then
				for n in ${pkg_grep[@]}; {
					public_pkg+=("$n")
				}
			else
				if ! (( LSKIPERROR )); then
					if (( LREMOVE )); then
						log_msg $ERR_ERROR "${red}error: ${orange}$x ${reset}target was ${red}NOT INSTALLED. ${reset}Use the ${yellow}${0##*/} -Sr ${reset}option to rebuild installed packages."
					else
						log_msg $ERR_ERROR "${red}error: ${orange}$x ${reset}target was ${red}NOT found. ${reset}Use the ${yellow}-Ss ${reset}option to search. "
					fi
					exit 1
				else
					log_msg $ERR_ERROR "${red}error${reset}: ${orange}${x} ${reset}target was ${red}NOT ${reset}found. ${yellow}Skipping"
				fi
				public_pkg_not_found+=("$x")
			fi

			if ! (( LREMOVE )); then
				if ! (( LSEARCHONLY )); then
					pkginstalled=$(grep ^"$x""$SEP" "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" | cut -d"$SEP" "$SEARCH_CUT")
					if [[ -n "$pkginstalled" && "${pkginstalled##*/}" = "${pkg_grep##*/}" ]]; then
						log_msg $ERR_ERROR "${yellow}atenção${reset}: ${orange}${pkginstalled##*/} ${reset}está atualizado -- reinstalando."
		 			fi
	  			fi
 			fi
		done
	fi

	public_ntotal_pkg_listed=$(arraylen "${public_pkg[@]}")
	if ((public_ntotal_pkg_listed )); then
		nstatus=$public_ntotal_pkg_listed
		if ! (( LREMOVE )); then
			if (( LDEPS )); then
				sh_getdeps $LDEPS || return 1
				public_pkg+=("${public_pkg_deps[@]}")
			fi
		fi
		#sanitize
		public_pkg=("$(sh_adel "${public_pkg[@]}")")
		public_ntotal_pkg_listed=$(lenarray "${public_pkg[@]}")
		if (( LSHOW )); then
			sh_writetable "${public_pkg[@]}" '0' "$public_ntotal_pkg_listed" "$nstatus"
		fi
		return 0
	fi
	return 1
}

function sh_writetable() {
#	local arr=($1)
	local arr
	local campo="$2"
	local nfiles=$3
	local nstatus=$4
	local status
	mapfile -t arr <<< "$(printf "%s\n" "$*:1")"

	if (( nfiles)); then
		if (( verbose >= 2)); then
			sh_cabec "$nfiles"
			pkgNumber=0

			for i in ${arr[@]}; do
				if (( verbose >= 2 )); then
					[[ -n "$nstatus" ]] && ((pkgNumber > nstatus)) && status='dep' || status=' S '
#					if   grep -q ^"$i$SEP" "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT";
#					then status=' I '
#					else status=' A '
#					fi
				fi

				if [[ "$status" = 'dep' ]]; then
					if ! (( LDEPS )); then
						continue
					fi
				fi
				(( LLIST )) && sh_write "$i" "$campo" $((++pkgNumber)) "$status"
			done
		else
			if (( LTABLE )); then
				for i in ${arr[@]}; do
					if sh_ascanpkg "$i" "$campo"; then
						repo=${aPKGARRAY[4]%%/*}
						printf "%-70s\t%s\t%15s\n" \
								 "${bold}${pink}$repo/${white}${aPKGARRAY[0]}-${black}${aPKGARRAY[1]}" \
								 "${red}$(size_to_human "${aPKGARRAY[6]}")"	\
								 "${cyan}$strstatus"
					fi
				done
				printf "%s\n" "${reset}Packages ($nfiles)"
			else
#				printf "${bold}${black}%s\n${reset}Packages ($nfiles)\n" ${arr[*]}
				printf "${black}%s " 	"${arr[*]}"
				printf "${reset}\n%s\n"	"Packages ($nfiles)"
				printf "\t%s\n" "${yellow}TIP: ${red}use the option --table or --verbose for more details"
			fi
			return 0
		fi
		printf "${yellow}(%05d) %s\n" "$nfiles" "${cyan}packages listed${reset}"
	fi
	return 0
}

function sh_checknet() {
	# have internet?
	if curl --insecure "$SITE" >/dev/null 2>&- ; then
		(( verbose >= 2 )) && log_msg $ERR_OK "${cyan}Testing internet from ${SITE}"
		return 0
	fi
	(( verbose >= 2 )) && log_msg $ERR_ERROR "Testing internet from ${SITE} - No route to server ($SITE) - ABORTED."
	return 1
}

function sh_cdroot() {
	cd - >/dev/null 2>&-
}

function sh_selfupdate() {
	local param="$*"

	if ! (( LAUTO )) || ! (( LFORCE)); then
		echo
		conf "Update ${0##*/} from internet?"
		LAUTO=$?
	fi

	if (( LAUTO )) || (( LFORCE )); then
		local link="$PKG_RAW/updater/src/fetch"
		local tmp_dir_full="/tmp/${APP}"
		local tmp_dir="/tmp/${APP}/src"

		#internet?
		sh_checknet || return 1

		log_msg "Ok, let's do it..."
		#Ok, Puxe o arquivo do repositorio agora!
		[[ -d "${tmp_dir_full}" ]] && rm -r "${tmp_dir_full}"
		[[ -d "${tmp_dir}" ]] || mkdir -p "${tmp_dir}"
		pushd "${tmp_dir}" >/dev/null 2>&- || return 1
		log_info_msg "${cyan}Clonando $link"
		curl --insecure --silent --remote-name "${link}"
		evaluate_retval

		log_info_msg "${cyan}Permission and Copy archives"
		chmod +x "${tmp_dir}/fetch"
		evaluate_retval

		log_info_msg "${cyan}Copying file ${yellow}fetch ${red}to ${yellow}${0}"
		cp "${tmp_dir}/fetch" "$0"
		evaluate_retval

		log_info_msg "${cyan}Removing temporary files"
		[[ -d "${tmp_dir_full}" ]] && rm -r "${tmp_dir_full}"
		evaluate_retval
		log_info_msg "${violet}${0##*/} updated successfully, enjoy!"
		evaluate_retval
		exit 0
	fi
	sh_cdroot
	return 1
}

function sh_clean() {
	local param="$*"
	local lRetval=$false
	local	nfiles

	nfiles=$(find "$CACHEDIR_ARCHIVES" -type f -iname "*.$PKG_EXT" -type f  | wc -l)
	if ! (( nfiles )); then
		printf '' >| "$CACHEDIR_SEARCH/$PACKAGES_IN_CACHE"
		log_msg "${yellow}($nfiles) ${cyan}find packages in cache"
		return $lRetval
	fi

	if ! (( LAUTO )); then
		printf '%s\n' "Pacotes a serem mantidos:"
      printf '%s\n' "      Todos os pacotes instalados localmente"
		printf "\n"
		printf '%s\n' "Cache directory: $CACHEDIR_ARCHIVES/"
		conf "${blue}:: ${reset}Do you want to remove all packages from the cache?"
		LAUTO=$?
	fi

	if (( LAUTO )); then
		log_msg "${pink}Deleting downloaded package files"
		if [[ -d "$CACHEDIR_ARCHIVES" ]]; then
			rm -f "$CACHEDIR_ARCHIVES/*.$PKG_EXT*"
		else
			mkdir -p "$CACHEDIR_ARCHIVES"
		fi
		printf '' >| "$CACHEDIR_SEARCH/$PACKAGES_IN_CACHE"
		log_success_msg2 "${yellow}($nfiles) ${cyan}packages deleted"
		lRetval=$true
	fi
	sh_cdroot
	return $lRetval
}

function sh_checkdir() {
	local i
	local -a aDir
	aDir+=("$CACHEDIR_ARCHIVES")
	aDir+=("$CACHEDIR_SEARCH")
	aDir+=("$CACHEDIR_LIST")
	aDir+=("$CACHEDIR_DESC")
	aDir+=("$CACHEDIR_REMO")

	(( verbose >= 2 )) && log_msg "Checking job directories"

	for i in ${aDir[@]}; do
		(( verbose >= 2 )) && log_info_msg "$i"
		if [[ -d "$i" ]]; then
			(( verbose >= 2 )) && evaluate_retval
		else
			mkdir -p "$i"  >/dev/null 2>&-
			(( verbose >= 2 )) && evaluate_retval
		fi
	done
	[[ -e "$CACHEDIR_SEARCH/$PACKAGES_SPLIT"           ]] || printf '' >| "$CACHEDIR_SEARCH/$PACKAGES_SPLIT"
	[[ -e "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" ]] || printf '' >| "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"

	return $?
}

# -Sy
function sh_updaterepo() {
	local response

	verbose=2
	if (( LSELF )); then
		sh_selfupdate "$@"
		return $?
	fi

	local nfilesInReposit
	local nfilesInstalled
	local response
	local dw=("$FOLDERS_METAPACKAGES"
		 		 "$METAPACKAGES"
		 		 "$PACKAGES_SPLIT"
		 		)
	#internet?
	sh_checknet || return 1
	response=$(curl --compressed -s -w "%{http_code}\n" -o /dev/null -k --url "${SITE}/repo/")
	if [[ $response -eq 404 ]]; then
		log_msg $ERR_ERROR "${red}error${reset}: $response Not Found ${orange}==> $SITE/repo/"
		return 1
	fi

	pushd "$CACHEDIR_SEARCH/" >/dev/null 2>&- || return 1
	sh_backup

	for i in ${dw[@]}; do
		rm -f "$CACHEDIR_SEARCH/$i"
	done
	log_msg "${pink}Cleaning up ${CACHEDIR_SEARCH}/${reset}"

	log_msg "${pink}Updating file packages from ${SITE}/repo/${reset}"
	curl --silent --insecure -O "$SITE/repo/${dw[0]}" -O "${SITE}/repo/${dw[1]}" -O "${SITE}/repo/${dw[2]}"
	sh_cleaning
	unset FOLDER_TEMP

	nfilesInReposit=$( sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" )
	nfilesInstalled=$( sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" )
	log_msg "${cyan}All list packages updated!${reset}"
	log_msg "${blue}($(strzero "$nfilesInReposit" 5)) packages in the repository${reset}"
	log_msg "${green}($(strzero "$nfilesInstalled" 5)) installed packages${reset}"
	echo
	msg "${reset}Use: # ${0##*/} --help for helping${reset}"
	popd >/dev/null 2>&- || return 1
}

# -Syy
function sh_update() {
	local response
	local Folders
	local FoldersInRepo
	local PackagesInFolders
	local MetaPkgInFolders
	local MetaInFolder
	local cstrvalue
	local response
	local count
	local nfilesInReposit
	local nfilesInstalled
	local nfilesInCache
	local oldverbose=$verbose
	local dw=("$CACHEDIR_SEARCH/$PACKAGES_SPLIT"
             "$CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES"
             "$CACHEDIR_SEARCH/$METAPACKAGES"
            )

	verbose=2
	if (( LSELF )); then
		sh_selfupdate "$@"
		return $?
	fi

	#internet?
	sh_checknet || return 1

	response=$(curl --compressed -s -w "%{http_code}\n" -o /dev/null -k --url "$SITE/packages/")
	if [[ "$response" = "404" ]]; then
		log_msg $ERR_ERROR "${red}error${reset}: $response Not Found $orange==> $SITE/packages/"
		exit 1
	fi

	pushd "$CACHEDIR_SEARCH/" >/dev/null 2>&- || return 1
	sh_backup

   for i in ${dw[@]}; do
      printf '' >| "$i"
   done
	log_msg "${pink}Cleaning up $CACHEDIR_SEARCH/"

	mapfile -t FoldersInRepo <<< "$(lynx -listonly -nonumbers -dump -justify "$SITE/packages/" | grep -Po '.*packages\/\K.*?(?=\/)')"
	log_msg "${pink}Updating folders from $SITE"

	log_msg "${pink}Synchronizing package databases from $SITE/packages/"
#	spinner & SPINNERPID=$!

	for Folders in "${FoldersInRepo[@]}"; do
		FOLDER_TEMP="$TMP_DIR_FOLDERS/$Folders"
		response=$(curl --compressed -k -s -w "%{http_code}\n" --url "$SITE/packages/$Folders/" --output "$FOLDER_TEMP")
		if [[ "$response" = "404" ]]; then
			log_msg $ERR_ERROR "${red}error${reset}: $response Not Found ${orange}==> $SITE/packages/$Folders/"
			exit 1
		fi
		mapfile -t SizePkgInFolders < <(sed -nE "s/$SED_RE/\9/p" "$FOLDER_TEMP")

		if [[ "$Folders" != "meta" ]]; then
			if (( CHILI_OS )); then
				mapfile -t PackagesInFolders < <(sed -nE "s/$SED_RE/\1-\2-\5\6/p" "$FOLDER_TEMP")
			else
				mapfile -t PackagesInFolders < <(sed -nE "s/$SED_RE/\1-\2\6/p" "$FOLDER_TEMP")
			fi
			count=0
			for pkgInFolder in "${PackagesInFolders[@]}"; do
				if [[ -n "$pkgInFolder" ]]; then
					sh_splitpkg "$pkgInFolder"
					pkg_size=$(human_to_bytes "${SizePkgInFolders[$count]}")
					echo "${aPKGSPLIT[$PKG_BASE]}$SEP${aPKGSPLIT[$PKG_VERSION]}$SEP${aPKGSPLIT[$PKG_BUILD]}$SEP${aPKGSPLIT[$PKG_FULLNAME]}$SEP${Folders}/${pkgInFolder}$SEP${aPKGSPLIT[$PKG_BASE_VERSION]}$SEP${pkg_size}" >> "$CACHEDIR_SEARCH/$PACKAGES_SPLIT"
					(( ++count ))
				fi
			done
		else
			mapfile -t MetaPkgInFolders <<< "$(lynx -listonly -nonumbers -dump "$SITE/packages/$Folders/" | grep -Po '.*\/\K.*')"
			count=0
			for MetaInFolder in "${MetaPkgInFolders[@]}"; do
				echo "$Folders/$MetaInFolder" >> "$FOLDERS_METAPACKAGES"
				echo "$MetaInFolder"          >> "$METAPACKAGES"
				(( ++count ))
			done
		fi
		log_msg "Updating... ${red}$(strzero "$count" 5)${blue} packages in ${yellow}$Folders"
	done
#	{ kill $SPINNERPID; wait $SPINNERPID 2>/dev/null; echo ;}

#	LLIST=$true ; sh_recreatefilepackagesinstalled
	verbose=$oldverbose
	sh_pkgincache
	sh_cleaning
	unset FOLDER_TEMP

	nfilesInReposit=$(sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_SPLIT")
	nfilesInstalled=$(sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT")
	nfilesInCache=$(sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_IN_CACHE")
	log_msg "${pink}All list packages updated!"
	log_msg "${red}$(strzero "$nfilesInReposit" 5) ${bold}${green}packages in the repository"
	log_msg "${red}$(strzero "$nfilesInstalled" 5) ${bold}${green}installed packages"
	log_msg "${red}$(strzero "$nfilesInCache" 5) ${bold}${green}packages in cache $CACHEDIR_ARCHIVES"
	echo
	msg "${reset}Use: # ${0##*/} --help for helping${reset}"
	popd >/dev/null 2>&- || return 1
}

function sh_updateMazon() {
	local nfilesInReposit
	local nfilesInstalled
	local nfilesInCache
	local HTTP_SERVER
	local response
	local Folders
	local count
	local dw=("$CACHEDIR_SEARCH/$PACKAGES_SPLIT" "$CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES" "$CACHEDIR_SEARCH/$METAPACKAGES")

	(( LSELF )) && { sh_selfupdate "$@"; return $?; }
	sh_checknet ||	return 1
	if (( response=$(curl --compressed -s -w "%{http_code}\n" -o /dev/null -k --url "${SITE}/packages/") -eq 404 )); then
		log_msg $ERR_ERROR "${red}error${reset}: $response Not Found ${orange}==> $SITE/packages/"
		exit 1
	fi

	pushd "$CACHEDIR_SEARCH/" >/dev/null 2>&- || return 1
	sh_backup

	log_msg "${pink}Cleaning up ${CACHEDIR_SEARCH}/${reset}"
   for i in ${dw[@]}; do
      printf '' >| "$i"
   done
	HTTP_SERVER="$(string_alltrim "$(curl --compressed -s -k --head -w '%{http_code}\n' --url "${SITE}" | grep '^[Ss]erver' | awk '{print $2}')" | cut -d/ -f1)"

	log_msg "${pink}Updating folders from ${SITE}${reset}"
	case ${HTTP_SERVER} in
		Apache|nginx) mapfile -t FoldersInRepo <<< "$(curl --compressed -k -s --url "${SITE}/packages/"|grep -Po '>[[:alnum:]]*/'|sed 's/>//g;s/\///g' | tee "$CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES")";;
	  	LiteSpeed|cloudflare) mapfile -t FoldersInRepo <<< "$(curl --compressed -k -s --url "${SITE}/packages/"|grep -Po 'packages\/[a-z]+'|sed 's/packages\///g' | tee "$CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES")";;
		GitHub.com) mapfile -t FoldersInRepo <<< "$(curl --compressed -k -s --url "$SITE/packages/"|grep /packages/ |sed 's/<[^>]*>//g;s/ //g' | tee "$CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES")";;
	esac

	log_msg "${pink}Synchronizing package databases from ${SITE}${reset}"
	#spinner & SPINNERPID=$!

	for Folders in ${FoldersInRepo[@]}; do
		FOLDER_TEMP="$TMP_DIR_FOLDERS/$Folders"
		response=$(curl --compressed --insecure -s -w "%{http_code}\n" -k --url "$SITE/packages/$Folders/" --output "$FOLDER_TEMP")
		case ${HTTP_SERVER} in
			Apache|nginx)
				if [[ $Folders != "meta" ]]; then
				   mapfile -t PackagesInFolders < <(grep -Eo '>'"$PKG_RE"'<' "$FOLDER_TEMP" | sed 's/>//g; s/<//g')
				else
					mapfile -t MetaPkgInFolders < <(grep -E '.meta\"' "$FOLDER_TEMP" | cut -d'"' -f2 )
				fi
				mapfile -t SizePkgInFolders < <(grep -E "$GREP_RE" "$FOLDER_TEMP" | awk '{print $5}' )
				;;
			LiteSpeed|GitHub.com|cloudflare)
				if [[ $Folders != "meta" ]]; then
					mapfile -t PackagesInFolders <<< "$(sed 's/^.*href="//' "$FOLDER_TEMP" | sed 's/".*$//' | sed 's/\// /g' | grep -E ".${PKG_EXT}$"| awk '{print $NF}')"
				else
					mafile -t MetaPkgInFolders <<< "$(sed 's/^.*href="//' "$FOLDER_TEMP" | sed 's/".*$//' | sed 's/\// /g' | grep -E ".meta$" | awk '{print $NF}')"
				fi
				mapfile -t SizePkgInFolders < <(grep -E "$GREP_RE $FOLDER_TEMP" | awk '{print $9}' | cut -d'"' -f2)
				;;
		esac

		count=0
		if [[ $Folders != "meta" ]]; then
			for pkgInFolder in "${PackagesInFolders[@]}"; do
				sh_splitpkg "$pkgInFolder"
				pkg_size="${SizePkgInFolders[$count]}"
				echo "${aPKGSPLIT[$PKG_BASE]}$SEP${aPKGSPLIT[$PKG_VERSION]}$SEP${aPKGSPLIT[$PKG_BUILD]}$SEP${aPKGSPLIT[$PKG_FULLNAME]}$SEP${Folders}/${pkgInFolder}$SEP${aPKGSPLIT[$PKG_BASE_VERSION]}$SEP${pkg_size}" >> "$CACHEDIR_SEARCH"/"$PACKAGES_SPLIT"
				((count++))
			done
		else
			for MetaInFolder in "${MetaPkgInFolders[@]}"; do
				echo "${Folders}/${MetaInFolder}" >> "$FOLDERS_METAPACKAGES"
				echo "${MetaInFolder}"            >> "$METAPACKAGES"
				((count++))
			done
		fi
		cstrvalue=$(strzero "$count" 5)
		log_success_msg2 "  Updating... (${blue}${cstrvalue}${reset}) packages in ${Folders}"
	done
#	{ kill $SPINNERPID; wait $SPINNERPID 2>/dev/null; echo ;}

	#sh_recreatefilepackagesinstalled
	sh_pkgincache
	sh_cleaning
	unset FOLDER_TEMP

	nfilesInReposit=$(wc -l < "$CACHEDIR_SEARCH/$PACKAGES_SPLIT")
	nfilesInstalled=$(wc -l < "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT")
	nfilesInCache=$(wc -l < "$CACHEDIR_SEARCH/$PACKAGES_IN_CACHE")
	log_msg "${cyan}All list packages updated!${reset}"
	log_msg "${blue}($(strzero "$nfilesInReposit" 5)) packages in the repository${reset}"
	log_msg "${green}($(strzero "$nfilesInstalled" 5)) installed packages${reset}"
	log_msg "${green}($(strzero "$nfilesInCache" 5)) packages in cache $CACHEDIR_ARCHIVES${reset}"
	echo
	log_msg "${reset}Use: # ${0##*/} --help for helping${reset}"
	popd >/dev/null 2>&- || return 1
}

function sh_filesincache() {
	local -i nfilesincache
   local item
   local pkg_base
   local cline
   local aCacheFullname

	(( verbose >= 2 )) && log_msg "Recreating IN CACHE packages list"
	printf '' >| "$CACHEDIR_SEARCH/$PACKAGES_IN_CACHE"
	mapfile -t aCacheFullname < <(find "$CACHEDIR_ARCHIVES/" -iname "*.$PKG_EXT" -type f | sort)
	nfilesincache="${#aCacheFullname[*]}"

   if (( nfilesincache )); then
   	nfilesincache=0
#   	for item in ${aCacheFullname[*]}; do
   	for item in "${aCacheFullname[@]}"; do
			((++nfilesincache))
			sh_splitpkg "$item"
			pkg_base="${aPKGSPLIT[$PKG_BASE]}"
			aCache+=("$pkg_base")
			cline=$(clinesplit)
       	echo "$cline" >> "$CACHEDIR_SEARCH/$PACKAGES_IN_CACHE"
#			(( verbose >= 2 )) && sh_write "$pkg_base" "0" "$nfilesincache"
   	done
   fi
#	(( verbose >= 2 )) && printf "${yellow}(%05d) %s\n" "$nfilesincache" "${cyan}packages IN CACHE $CACHEDIR_ARCHIVES"
   return 0
}

# -Pi
function sh_pkgincache() {
	local lfind=$false
	local nfilesoutcache=0
	local nfilesincache=0
	local aPkgOut
	local aPkgIn
	local x
	local y
	local indice=0

	(( verbose >= 2 )) && log_msg "Ok, let's do it..."
	(( verbose >= 2 )) && log_msg "Wait, doing some calculations..."
	sh_filesincache

	nfilesincache="${#aCache[*]}"
	sh_writetable "${aCache[*]}" '0' "$nfilesincache"

:<<'comment'
#	for y in ${public_pkg_base[*]};do
	for y in "${public_pkg_base[@]}";do
		if ! ascan "$y" "${aCache[@]}"; then
			((++nfilesoutcache))
  		   aPkgOut+=("${public_pkg_base_version[$indice]}")
		else
			((++nfilesincache))
			(( verbose >= 2 )) && sh_write "$y" "0" "$nfilesincache"
			aPkgIn+=("${public_pkg_base_version[$indice]}")
		fi
		((++indice))
	done
	sh_writetable "${aPkgIn[*]}" '5' "$nfilesincache"
comment

	if (( verbose >= 2 )); then
		printf "${yellow}(%05d) %s\n" "$nfilesincache" "${cyan}packages in cache"
		printf "${yellow}(%05d) %s\n" "$nfilesoutcache" "${cyan}packages OUT CACHE $CACHEDIR_ARCHIVES"
		printf "${yellow}(%05d) %s\n" "$public_len_count_pkg" "${cyan}packages in the repository${reset}"
	fi
	return 0
}

function ascan() {
	local e match="$1"
	shift
	for e; do [[ "$e" == "$match" ]] && return 0; done
	return 1
}

# -Po
function sh_pkgoutcache() {
	local lfind=$false
	local nfilesoutcache=0
	local nfilesincache=0
	local aPkgOut
	local aPkgIn
	local x
	local y
	local indice=0

	(( verbose >= 2 )) && log_msg "Ok, let's do it..."
	(( verbose >= 2 )) && log_msg "Wait, doing some calculations..."
	sh_filesincache

#	for y in ${public_pkg_base[*]};do
	for y in "${public_pkg_base[@]}";do
		if ! ascan "$y" "${aCache[@]}"; then
			((++nfilesoutcache))
			(( verbose >= 2 )) && sh_write "$y" "0" "$nfilesoutcache"
#			aPkgOut+=("$y")
			aPkgOut+=("${public_pkg_base_version[$indice]}")
		else
			((++nfilesincache))
#			aPkgIn+=("$y")
			aPkgIn+=("${public_pkg_base_version[$indice]}")
		fi
		((++indice))
	done

	sh_writetable "${aPkgOut[*]}" '5' "$nfilesoutcache"

	if (( verbose >= 2 )); then
		printf "${yellow}(%05d) %s\n" "$nfilesincache" "${cyan}packages in cache"
		printf "${yellow}(%05d) %s\n" "$nfilesoutcache" "${cyan}packages OUT CACHE $CACHEDIR_ARCHIVES"
		printf "${yellow}(%05d) %s\n" "$public_len_count_pkg" "${cyan}packages in the repository${reset}"
	fi
	return 0
}

sh_CatAndSizePkg() {
	local cpacote="$1"
	local LSHOW="$2"
	local lresult=$ERR_OK

  	if [[ -e "$cpacote" ]]; then
  		source "$cpacote"
		if (( LSHOW )); then
			printf '%s\n' "${cyan}BaseName     : ${yellow}${aPKGSPLIT[$PKG_FOLDER_DIR]}/${aPKGSPLIT[$PKG_FULLNAME]}"
			printf '%s\n' "${cyan}Name         : ${yellow}${pkgname}"
			printf '%s\n' "${cyan}Version      : ${yellow}${version}"
			printf '%s\n' "${cyan}Build        : ${yellow}${build}"
			printf '%s\n' "${cyan}Description  : ${yellow}${desc}"
			printf '%s\n' "${cyan}Architecture : ${yellow}${arch}"
			printf '%s\n' "${cyan}URL          : ${yellow}${url}"
			printf '%s\n' "${cyan}Licenses     : ${yellow}${license}"
			printf '%s\n' "${cyan}Dependencies : ${yellow}${depend}"
			printf '%s\n' "${cyan}Dependencies : ${yellow}${dep}"
			printf '%s\n' "${cyan}Size         : ${yellow}$(size_to_human "$size")"
			printf '%s\n' "${cyan}Packer       : ${yellow}${maintainer}"
			printf '%s\n' "${cyan}Distro       : ${yellow}${distro}"
			printf '%s\n' "${cyan}Init         : ${yellow}${lfs_init}"
			printf '%s\n' "${cyan}LSB          : ${yellow}${lfs_version}"
	    	printf '%s\n' "${reset}"
		fi
		unset pkgname version build desc arch url license depend dep size mainteiner distro lfs_init lfs_version
  	else
  		lresult=$ERR_ERROR
  	fi
	return $lresult
}

sh_ShortCatPkg() {
	local cpacote="$1"
	local LSHOW=$2
	local lresult=$ERR_OK
	local cpackage="${aPKGSPLIT[$PKG_BASE]}"
	local SEARCH_CUT='-f5'
	local pkginstalled=

  	if [[ -e "$cpacote" ]]; then
  		source "$cpacote"
		if (( LSHOW )); then
			pkginstalled=$(grep ^"$cpackage$SEP" "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" | cut -d"$SEP" "$SEARCH_CUT")
			if [[ -z "$pkginstalled" ]]; then
				printf "%s  %s %s\n" "${pink}${aPKGSPLIT[$PKG_FOLDER_DIR]}/${yellow}${aPKGSPLIT[$PKG_BASE]}" "${green}${aPKGSPLIT[$PKG_VERSION]}" "${white}${desc::40}"
			else
				printf "%s  %s %s\n" "${pink}${aPKGSPLIT[$PKG_FOLDER_DIR]}/${yellow}${aPKGSPLIT[$PKG_BASE]}" "${green}${aPKGSPLIT[$PKG_VERSION]}" "${cyan}[installed] ${white}${desc::40}"
			fi
	    	printf '%s' "${reset}"
		fi
		unset pkgname version desc arch url license depend dep size maintainer distro lfs_init lfs_version
  	else
  		lresult=$ERR_ERROR
  	fi
	return $lresult
}

# -Qi
function sh_show() {
	local param="$*"
	local saveverbose=$verbose
	local ntotal_pkg_listed
	local cpacote
	local lresult=$ERR_ERROR

	(( verbose >= 2  )) && log_msg "Reading package list..."
	verbose=0
	LDEPS=$false
	LEXACT=$true
	sh_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" "$param"
	ntotal_pkg_listed="$public_ntotal_pkg_listed"
	verbose=$saveverbose

	if (( ntotal_pkg_listed )); then
		for i in ${public_pkg[@]}; do
			sh_splitpkg "$i"
			cpacote="$CACHEDIR_ARCHIVES/${aPKGSPLIT[1]}.desc"

			if (( LFORCE )) || ! [[ -e "$cpacote" ]]; then
				if ! sh_wgetdesc "$i"; then
					continue
				fi
    		fi
			sh_CatAndSizePkg "$cpacote" $true
		done
		lresult=$ERR_OK
	fi
	return $lresult
}

# -Ss
function sh_search() {
	local param="$*"
	local saveverbose=$verbose
	local ntotal_pkg_listed
	local cpacote
	local lresult=$ERR_ERROR

	(( verbose >= 2  )) && log_msg "Reading package list..."
	verbose=0
	LDEPS=$false
#	LEXACT=$true
	sh_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" "$param"
	ntotal_pkg_listed="$public_ntotal_pkg_listed"
	verbose=$saveverbose

	if (( ntotal_pkg_listed )); then
		for i in ${public_pkg[@]}; do
			sh_splitpkg "$i"
			cpacote="$CACHEDIR_ARCHIVES/${aPKGSPLIT[1]}.desc"

			if (( LFORCE )) || ! [[ -e "$cpacote" ]]; then
				if ! sh_wgetdesc "$i"; then
					continue
				fi
    		fi
         sh_ShortCatPkg "$cpacote" $true
		done
		lresult=$ERR_OK
	fi
	return $lresult
}

# -R
sh_remove() {
#	local param="$@"
	local param="$*"
	local x
	local cPkgFullFilename
	local ntotal_pkg_listed

	LDEPS=$false
	LEXACT=$true
	LREMOVE=$true
	sh_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" "$param"
	ntotal_pkg_listed="$public_ntotal_pkg_listed"

	if (( ntotal_pkg_listed )); then
		if ! (( LAUTO )); then
			echo
			confno "${blue}::${reset} Remove package(s)?"
			LAUTO=$?
		fi

		if (( LAUTO )); then
			for cPkgFullFilename in ${public_pkg[@]}; do
				sh_splitpkg "$cPkgFullFilename"
				sh_doremove "${aPKGSPLIT[$PKG_BASE_VERSION]}" "$cPkgFullFilename"
			done
		fi
	else
		echo
		#log_msg $ERR_ERROR "${red}error${reset}:${orange}${public_ListSearch} ${reset}not installed."
		return $ERR_ERROR
	fi
	return $ERR_OK
}

sh_doremove() {
	local cPkgBaseVersion="$1"
	local cPkgFullFilename="$2"

	log_wait_msg "Wait, Removing package ${orange}$cPkgFullFilename"
	if sh_removepkg "$cPkgBaseVersion" "$cPkgFullFilename"; then
		if (( LLIST )); then
			log_success_msg2 "${green}$cPkgFullFilename${reset} Done. Removal of the package successfully completed"
		fi
		return $ERR_OK
	fi
	return $ERR_ERROR
}

sh_removepkg() {
	local cPkgBaseVersion="$1"
	local cPkgFullFilename="$2"

	sh_pre_remove "$cPkgBaseVersion" || return $ERR_ERROR
#	sh_splitpkg "$cPkgFullFilename"  || return $ERR_ERROR
	if sed -i  '/'"$cPkgBaseVersion"'/d' "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"; then
		return $ERR_OK
	fi
	return $ERR_ERROR
}

sh_remove_now() {
	local cPkgBaseVersion="${1/%.${PKG_EXT}/}"
	local thefile

	pushd "/" >/dev/null 2>&- || return 1

	if [[ -e "${CACHEDIR_REMO}/${cPkgBaseVersion}.rm" ]]; then
		sed -E "/rm[[:space:]]+\-(rf|fr)/d" "${CACHEDIR_REMO}/${cPkgBaseVersion}.rm" >/dev/null 2>&-
		bash "${CACHEDIR_REMO}/${cPkgBaseVersion}.rm"
		rm "${CACHEDIR_REMO}/${cPkgBaseVersion}.rm" >/dev/null 2>&-
	fi

	while IFS= read -r thefile; do
		if [[ -f "$thefile" ]]; then
			rm "$thefile" >/dev/null 2>&- && print "Delete\t${thefile}"
		fi
		if [[ -L "$thefile" ]]; then
			unlink "$thefile" >/dev/null 2>&-
		fi
		if [[ -d "$thefile" ]] && [[ -z "$(ls -A "$thefile")" ]]; then
			rmdir -p "${thefile}" >/dev/null 2>&-
		fi
	done < "${CACHEDIR_LIST}/${cPkgBaseVersion}.list"

	popd >/dev/null 2>&- || return 1
	IFS=$SAVEIFS

	if ! rm "$CACHEDIR_DESC/$cPkgBaseVersion.desc" >/dev/null 2>&-; then { log_msg $ERR_ERROR "Error, It was not possible remove $CACHEDIR_DESC/$cPkgBaseVersion.desc" ; return 1; } fi
	if ! rm "$CACHEDIR_LIST/$cPkgBaseVersion.list" >/dev/null 2>&-; then { log_msg $ERR_ERROR "Error, It was not possible remove $CACHEDIR_LIST/$cPkgBaseVersion.list" ; return 1; } fi
	return $ERR_OK
}

sh_pre_remove() {
	local cPkgBaseVersion="$1"
	local cExtList="$cPkgBaseVersion.list"

	if [[ -e "$CACHEDIR_LIST/$cExtList" ]]; then
		sh_remove_now "$cPkgBaseVersion"
		return $ERR_OK
	else
		log_msg $ERR_ERROR "Error, file not found: ${red}$CACHEDIR_LIST/$cExtList"
		return $ERR_ERROR
	fi
}

# -Sw
function sh_download() {
	local param="$*"
	local error_value=0
	local nFilesDownloaded=0

	LDEPS=$false
	LEXACT=$true
	sh_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" "$param"
	local ntotal_pkg_listed="${public_ntotal_pkg_listed}"

#	sh_checknet || return 1

	if [[ -n "${public_pkg[*]}" ]]; then
		pushd "$CACHEDIR_ARCHIVES/" >/dev/null 2>&- || return 1

		for i in ${public_pkg[@]}; do
			sh_splitpkg "$i"
			local cfullname="${aPKGSPLIT[$PKG_FULLNAME]}"
			if test -e "$CACHEDIR_ARCHIVES/$cfullname"; then
	    		if ! (( LFORCE )); then
					log_msg $ERR_ERROR "${orange}${i##*/} ${reset}Package is already downloaded. Use the -f option to force download."
					popd >/dev/null 2>&- || return 1
					return 1
				fi
			fi
			sh_wgetdesc "$i"
			if sh_wgetfull "$i"; then
				(( ++nFilesDownloaded ))
			fi
		done
		msg "${cyan}($nFilesDownloaded) package(s) downloaded."
		popd >/dev/null 2>&- || return 1
	fi
}

function sh_sanitize_deps() {
	local arr=("${@:1}")
	local cdep

	for i in ${arr[@]}; do
		cdep="${i%%=*}"
		cdep="${cdep%%.so*}"
		cdep="${cdep#lib}"
	done
	return 0
}

sh_getdeps()
{
	local ncontadep=0
	local	arr
	local pkgNumber=0
   local cfullfilename
   local x
   local LDEPS=$1
   local ndep

  	GETDEPS=()
  	deps=()

	(( verbose >= 2 )) && log_msg "Solving dependencies"

	for i in ${public_pkg[@]}; do
		sh_splitpkg "$i"
		cbase="${aPKGSPLIT[PKG_BASE]}"
		cfullfilename="${aPKGSPLIT[PKG_FULLNAME]}"
	   [[ -e "$CACHEDIR_ARCHIVES/$cfullfilename.desc" ]] || sh_wgetdesc || return 1
	   source "$CACHEDIR_ARCHIVES/$cfullfilename.desc"
		if (( LDEPS )); then
	     	deps+=("${dep[*]}")
      	deps+=("$(grep ^depend "$CACHEDIR_ARCHIVES/$cfullfilename.desc" | awk -F"'" '{print $2}')")
      fi
   done

	#sanitize deps
	deps=("$(sh_adel "${deps[*]}")")
  	adeps=${deps[*]}
	deps=()

	for i in ${adeps[@]}; do
		cdep="${i%%=*}"
		cdep="${cdep%%.so*}"
		cdep="${cdep%%>=*}"
		cdep=$(grep -Po '^([a-z]+[-|_]?[a-z]+)' <<< "$i")

		if ! sh_ascanpkg "$cdep" "0"; then
			cdep="${cdep#lib}"
			if ! sh_ascanpkg "$cdep" "0"; then
				continue
			fi
		fi
		deps+=("$cdep")
	done
	deps=("$(sh_adel "${deps[*]}")")

  	for i in ${deps[@]}; do
  		((++ncontadep))
  		pkgdep=$(grep ^"$i$SEP" "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | awk -F"$SEP" '{print $5}')
  		if [[ -z "$pkgdep" ]]; then
			if (( verbose )); then
  				printf "${red}%s(%04d) ${orange}%-40s ${reset}%-40s\n" "     " "$ncontadep" "${i}" "WARNING! Dependency not found in the database. ${reset}Use: # fetch -Syy to update with the repository${reset}"
			fi
  		else
 			GETDEPS+=("$pkgdep")
			pkginstalled=$(grep ^"$i$SEP" "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" | awk -F"$SEP" '{print $5}')
#	  		if [[ -z "$pkginstalled" ]]; then
#				#GETDEPS+=("$pkgdep")
#				echo
#	  		fi
  		fi
  	done
# 	public_pkg_deps+=$GETDEPS
# 	public_pkg_deps+=${GETDEPS[*]}
 	public_pkg_deps+=("${GETDEPS[@]}")
   return $?
}

sh_splitarray() {
   local str=("$1")
   local pos="$2"
   local sep="${3:-'|'}"
   local array

   [[ $# -eq 3 && "$pos" = "|" && "$sep" =~ ^[0-9]+$ ]] && { sep="$2"; pos="$3";}
   [[ $# -eq 2 && "$pos" = "$sep"                    ]] && { sep="$pos"; pos=0;}
   [[ $# -eq 1 || ! "$pos" =~ ^[0-9]+$               ]] && { pos=0; }

#  IFS="$sep" read -r -a array <<< "$str"
   IFS="$sep" read -r -a array <<< "${str[@]}"
   echo "${array[pos]}"
}

sh_splitpkg() {
	file=$1
	declare -gA APKGSPLIT=()
	aPKGSPLIT=()
	pkg_folder_dir=${file%/*}										#remove arquivo deixando somente o diretorio/repo
	pkg_fullname=${file##*/}			    						#remove diretorio deixando somente nome do pacote

   [[ "$pkg_folder_dir" == "$pkg_fullname" ]] && pkg_folder_dir="localhost"
	if [[ "$pkg_fullname" =~ $PKG_RE ]] ; then
		pkg_fullname="${BASH_REMATCH[0]}"
		pkg_base="${BASH_REMATCH[1]}"
		pkg_version_build="${BASH_REMATCH[2]}"
		pkg_version="${BASH_REMATCH[3]}"
		pkg_build="${BASH_REMATCH[4]}"
		pkg_arch="${BASH_REMATCH[5]}"
		pkg_base_version="${pkg_base}-${pkg_version_build}"

:<<'comment'
		#debug "$pkg_base \n $pkg_version_build \n $pkg_version \n $pkg_build \n $pkg_arch \n $pkg_base_version \n"
		debug   " file            : $file\n" \
		        "pkg_folder_dir  : $pkg_folder_dir\n" \
			 	  "pkg_fullname    : $pkg_fullname\n" \
			 	  "pkg_arch        : $pkg_arch\n" \
			 	  "pkg_base        : $pkg_base\n" \
				  "pkg_base_version: $pkg_base_version\n" \
				  "pkg_version     : $pkg_version\n" \
				  "pkg_build       : $pkg_build"
comment
		APKGSPLIT+=(["$pkg_base"]="pkg_folder_dir|$pkg_fullname|$pkg_arch|$pkg_base|$pkg_base_version|$pkg_version-$pkg_build|$pkg_build")
		aPKGSPLIT=(	"$pkg_folder_dir"
					  	"$pkg_fullname"
						"$pkg_arch"
						"$pkg_base"
						"$pkg_base_version"
						"$pkg_version-$pkg_build"
						"$pkg_build"
						)
		return 0
	fi
	return 1
}

sh_splitpkgIFS()
{
	local file=$1
	local pkg_folder_dir
	local pkg_fullname
	local pkg_arch
	local pkg_base
	local pkg_base_version
	local pkg_version
	local pkg_build
	local pkg_str
	local nconta=0
	local char='-'
	local var
	local re

	aPKGSPLIT=()
	pkg_folder_dir="${file%/*}"									#remove arquivo deixando somente o diretorio/repo
	pkg_fullname="${file##*/}"			    						#remove diretorio deixando somente nome do pacote
	pkg_arch="${pkg_fullname%."$PKG_EXT"*}"					#remove extensao pacote (chi.zst/mz)
	pkg_arch="${pkg_arch%.arch1*}"		 						#remove extensao pacote (chi.zst/mz)
	pkg_arch="${pkg_arch##*-}"			 							#remove do começo até o ultimo -

	pkg_str="${pkg_fullname%-any."$PKG_EXT"*}"				#remove extensao pacote (chi.zst/mz)
	pkg_str="${pkg_str%."$PKG_EXT"*}" 							#remove extensao pacote (chi.zst/mz)
	pkg_str="${pkg_str%-x86_64*}"			 						#remove extensao pacote (chi.zst/mz)
	pkg_str="${pkg_str%."$PKG_EXT"*}"  							#remove extensao pacote (chi.zst/mz)

	IFS='-'
	read -ra ADDR <<< "$pkg_str"									# str is read into an array as tokens separated by IFS
	for var in "${ADDR[@]}"; do 									# access each element of array
		re='^[a-zA-Z]'
		if [[ "$var" =~ $re ]]; then
			pkg_base="$pkg_base${var}$char"
		else
			((nconta++))
			[[ $nconta -eq 1 ]] && pkg_version=$var || pkg_build=$var
		fi
	done
 	IFS=$SAVEIFS
	pkg_base=${pkg_base%-*}
	pkg_base_version="${pkg_base}-${pkg_version}-${pkg_build}"
	[[ $pkg_folder = "" ]] && pkg_folder=$pkg_fullname

	aPKGSPLIT=(	"$pkg_folder_dir"
					"$pkg_fullname"
					"$pkg_arch"
					"$pkg_base"
					"$pkg_base_version"
					"$pkg_version-$pkg_build"
					"$pkg_build"
				)

#	aPKGLIST=${aPKGSPLIT[*]}
#	arr=(${aPKGSPLIT[*]})
	return $?
}

sh_splitpkgawk()
{
	file=$1
	aPKGSPLIT=()

	pkg_folder_dir="${file%/*}"							#remove arquivo deixando somente o diretorio/repo
	pkg_fullname="${file##*/}"    						#remove diretorio deixando somente nome do pacote

#	arr=($(echo "$pkg_fullname" | awk 'match($0, /(.+)-(([^-]+)-([0-9]+))-([^.]+)\.chi\.zst/, array) {
#			print array[0]
#			print array[1]
#			print array[2]
#		   print array[3]
#		   print array[4]
#   		print array[5]
#    		print array[6]
#			}'))
	mapfile -t arr < <(echo "$pkg_fullname" | awk 'match($0, /(.+)-(([^-]+)-([0-9]+))-([^.]+)\.chi\.zst/, array) {
			print array[0]
			print array[1]
			print array[2]
		   print array[3]
		   print array[4]
    		print array[5]
    		print array[6]
			}')

	pkg_fullname="${arr[0]}"
	pkg_base="${arr[1]}"
	pkg_version_build="${arr[2]}"
	pkg_version="${arr[3]}"
	pkg_build="${arr[4]}"
	pkg_arch="${arr[5]}"
	pkg_base_version="${arr[0]}-${arr[4]}"

	aPKGSPLIT=(	"$pkg_folder_dir"
					"$pkg_fullname"
					"$pkg_arch"
					"$pkg_base"
					"$pkg_base_version"
					"$pkg_version-$pkg_build"
					"$pkg_build"
				)
	return $?
}

# -S
function sh_install() {
	local param="$*"
	local loldverbose=$verbose
	local ntotal_pkg_listed=0

	SPLITPOS='4'
	LTABLE=$true
	LEXACT=$true
	sh_listpkgdisp	"$CACHEDIR_SEARCH/$PACKAGES_SPLIT" "$param" || return 1
	ntotal_pkg_listed=$public_ntotal_pkg_listed
	verbose=$loldverbose

	if (( ntotal_pkg_listed )); then
		[[ -d $CACHEDIR_ARCHIVES/ ]] || mkdir -p "$CACHEDIR_ARCHIVES/"
		cd "$CACHEDIR_ARCHIVES/"     || return 1

		if ! (( LAUTO )); then
			if ! readconf "${blue}:: ${reset}Continue installation ?"; then
				return
			fi
		fi
		LFORCE=$true
      sh_installdownload || return 1
      sh_installdoinstallpkg
	fi
	sh_cdroot
}

function sh_installdownload() {
	local cfullfilename
	local cpacote
	local cpacotebase

	sh_checknet || return 1
	for i in ${public_pkg[@]}; do
		sh_splitpkg "$i"
		cfullfilename=${aPKGSPLIT[PKG_FULLNAME]}
		cpacote=${aPKGSPLIT[PKG_FULLNAME]}
		cpacotebase=${aPKGSPLIT[PKG_BASE]}

		[[ -e "$CACHEDIR_ARCHIVES/$cpacote" ]] || sh_wgetpartial "$i"
		local error_value=$?

		if [ ${error_value} -ne 0 ]; then
			log_msg $ERR_ERROR "ERROR: Downloading ${orange}${cfullfilename}"
			log_wait_msg "Restarting download ${orange}${cfullfilename}"
			sh_wgetfull
			local error_value=$?
			if [ ${error_value} -ne 0 ]; then
				log_msg $ERR_ERROR "${red}fatal error downloading ${orange}${cfullfilename}${reset}"
				exit 1
			fi
		fi
	done
}

function sh_wgetresponse() {
	local i="$1"
	local cfile="${i##*/}"
	local cfullfilename="$CACHEDIR_ARCHIVES/$cfile"
	local lresult
	local response

	(( verbose >= 2 )) && log_info_msg "${DOT}${cyan}Fetching package ${cRaw}/packages/${orange}${i}"
	response=$(curl -s -w "%{http_code}\n" -k -O "${cRaw}/packages/$i")
	lresult=$?
	(( verbose >= 2 )) && evaluate_retval $lresult

	if ! [[ $response -eq 200 ]]; then
		rm -f "$cfullfilename" >/dev/null 2>&-
		if ! (( LSKIPERROR )); then
			log_msg $ERR_ERROR "${red}response curl error: $response ${reset}NOT FOUND file ${orange}${cfile} ${reset}at $SITE/packages/ - Use the ${yellow}--skiperror ${reset}option to skip install."
		else
			log_msg $ERR_ERROR "${red}response curl error: $response ${reset}NOT FOUND file ${orange}${cfile} ${reset}at $SITE/packages/"
		fi
		return 1
	fi
	return 0
}

function sh_wgetpartial() {
	local cfullfilename="$1"
	local cRaw

	[[ -z "$cpacote" ]] && cpacote="${cfullfilename##*/}"
	(( GITSITE )) && cRaw="$RAW" || cRaw="$SITE"

	sh_wgetresponse "$i.desc" || return 1
	sh_wgetresponse "$i" 	  || return 1
}

function sh_wgetdesc() {
	local cfullfilename="$1"
	local cRaw
   local nretval=1

	(( GITSITE )) && cRaw="$RAW" || cRaw="$SITE"
	pushd "$CACHEDIR_ARCHIVES/" >/dev/null 2>&-
	sh_wgetresponse "$i.desc"
	nretval=$?
	popd >/dev/null 2>&-
	return $nretval
}

function sh_wgetfull() {
	local cfullfilename="$1"
	local cRaw
   local nretval

	(( GITSITE )) && cRaw="$RAW" || cRaw="$SITE"
	sh_wgetresponse "$i"
	nretval=$?
	return $nretval
}

function sh_installdoinstallpkg() {
	local LINSTALLED=$false
	local cpacoteinstalled

	for i in ${public_pkg[@]}; do
		sh_splitpkg "$i"
		local cfullfilename=${aPKGSPLIT[PKG_FULLNAME]}
		local cpacote=${aPKGSPLIT[PKG_FULLNAME]}
		local cpacotebase=${aPKGSPLIT[PKG_BASE]}
		local cBaseVersion=${aPKGSPLIT[$PKG_BASE_VERSION]}

		case "$cpacotebase" in
			gcc)	      log_msg $ERR_ERROR "Skipping package: $cpacotebase"; continue;;
			gcc-libs)   log_msg $ERR_ERROR "Skipping package: $cpacotebase"; continue;;
			glibc)	   log_msg $ERR_ERROR "Skipping package: $cpacotebase"; continue;;
			file)	      log_msg $ERR_ERROR "Skipping package: $cpacotebase"; continue;;
			flac)	      log_msg $ERR_ERROR "Skipping package: $cpacotebase"; continue;;
		esac

		cpacoteinstalled=$(grep ^"$cpacotebase$SEP" "${CACHEDIR_SEARCH}/$PACKAGES_INSTALLED_SPLIT" | cut -d"$SEP" -f6)
		[[ "$cpacoteinstalled" == "$cBaseVersion" ]] && LINSTALLED=$true || LINSTALLED=$false
		if (( LINSTALLED )) && ! (( LFORCE )); then
			log_msg "$ERR_ERROR" "${orange}${cBaseVersion} ${reset}Package is already installed. Use the -f option to force reinstallation."
			continue
		fi
		sh_installpkg "$cpacote"
		local error_value=$?
		if ! (( error_value )); then
			log_msg "${green}${cpacote} ${reset}Done. Package installation successfully."
		fi
	done
}

sh_listmeta() {
#	local param="$@"
	local param="$*"
	local cListSearch=$param
	local x
	local arr
	public_ntotal_pkg_meta=0

	LLIST=$true
	if (( verbose >= 2 )); then
		log_msg "Reading meta package lists in the repository..."
	fi

	if (( LALL )) || [[ -z "$cListSearch" ]]; then
		if (( LALL )); then
			metapkg=$(cat "$CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES")
		else
			log_msg $ERR_ERROR "${red}error${reset}: nenhum alvo definido (use -h para obter ajuda)"
			exit 1
		fi
	else
		for x in $cListSearch; do
			if (( LEXACT )); then
				cfile="$(grep "\/$x.meta$" "$CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES")"
			else
				cfile="$(grep "$x" "$CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES")"
			fi
			metapkg+="$cfile"

			if [[ -z $cfile ]]; then
				if ! (( LSKIPERROR )); then
					log_msg $ERR_ERROR "${red}error${reset}: ${orange}${x} ${reset}target was ${red}NOT ${reset}found. Use the ${yellow}--skiperror ${reset}option to force install. "
					exit 1
				else
					log_msg $ERR_ERROR "${red}error${reset}: ${orange}${x} ${reset}target was ${red}NOT ${reset}found. ${yellow}Skipping"
				fi
			fi
		done
	fi

	arr=("${metapkg[*]}")
	public_ntotal_pkg_meta=${#arr[*]}

	if (( public_ntotal_pkg_meta )); then
		if (( verbose >= 2 )); then
			log_msg "Listing... Done"
		fi
		for i in $metapkg; do
			(( LLIST )) && log_success_msg2 "${blue}FOUND ${orange}$i"
		done
		(( LLIST )) && log_success_msg2 "($public_ntotal_pkg_meta) meta package(s) found."
	else
		 log_msg $ERR_ERROR "${red}error: ${reset}target not found : ${orange}${param}"
	fi
	return "$public_ntotal_pkg_meta"
}

sh_installmeta() {
#	local param="$@"
	local param="$*"
	local pkgInMeta=()
	local cmetapackage

	sh_listmeta "$param"
	public_ntotal_pkg_meta=$?

	if (( public_ntotal_pkg_meta )); then
		if ! (( LAUTO )); then
			if ! readconf "${blue}:: ${reset}Continue installation ?"; then
				return
			fi
			LAUTO=$true
		fi

		pushd "$CACHEDIR_ARCHIVES/" >/dev/null 2>&- || return 1
		for cmetafile in $metapkg; do
			cmetapackage=$(echo "$cmetafile" | cut -d/ -f2)

			if ! (( GITSITE )); then
            curl --silent -k -O "$SITE/packages/$cmetafile"
			else
				curl --silent -k -O "$RAW/packages/$cmetafile"
			fi
			pkgInMeta+=("$(cat "$CACHEDIR_ARCHIVES/$cmetapackage")")
		done

		popd >/dev/null 2>&- || return 1
		param="${pkgInMeta[*]}"

#		[[ $verbose -eq 0 ]] && (( verbose=1 ))
		verbose=0
		sh_listpkgdisp	"$CACHEDIR_SEARCH/$PACKAGES_SPLIT" "$param"
		local ntotal_pkg_listed=${public_ntotal_pkg_listed}

		if [[ $public_pkg != "" ]]; then
			[[ -d "$CACHEDIR_ARCHIVES/" ]] || mkdir -p "$CACHEDIR_ARCHIVES/"
			cd "$CACHEDIR_ARCHIVES/" || return 1

			if ! (( LAUTO )); then
				if ! readconf "${blue}:: ${reset}Continue installation ?"; then
					return
				fi
			fi
	      sh_installdownload
	      sh_installdoinstallpkg
		fi
		sh_cdroot
	fi
}

sh_recreateFilesFromArch()
{
	local item
	local nfiles
	local aCache

	(( verbose >= 2 )) && log_msg "Fixing packages installed by pacman"
	pushd "/var/lib/pacman/local/" >/dev/null 2>&- || return 1
	mapfile -t aCache < <(printf '%s\n' *)
	nfiles=$(lenarray "${aCache[*]}")
	popd >/dev/null 2>&- || return 1

   if (( nfiles )); then
#   	for item in $aCache; do
   	for item in "${aCache[@]}"; do
   		[[ "$item" == "ALPM_DB_VERSION" || $item == ',,,,' || -z $item ]] && continue;
			[[ -f "$CACHEDIR_DESC/$item.desc" ]] || printf '' >| "$CACHEDIR_DESC/$item.desc"
   	done
		return 0
   fi
   return 1
}

# -Sr
function sh_recreatefilepackagesinstalled() {
	local re='(.+)-(([^-]+)-([0-9]))+[.](desc)$'
	local item
	local package
   local pkgNumber=0
   local nfiles
   local aCache
   local lresult=1
	local cbase

	(( verbose >= 2 )) && log_msg "Recreating installed packages list"
	sh_recreateFilesFromArch
	(( verbose >= 2 )) && log_msg "Reading lists of installed packages"

	printf '' >| "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
	mapfile -t aCache < <(printf '%s\n' "$CACHEDIR_DESC"/* | awk -F "$re" 'list[$1]++')
#2	aCache=$(grep -Po "$re" < <(printf '%s\n' $CACHEDIR_DESC/*) )
#1	aCache=$(find $CACHEDIR_DESC/ -regextype posix-egrep -regex "$re" -type f | sort -V)
	nfiles=$(arraylen "${aCache[@]}")
	pkgnumber=0

   if (( nfiles )); then
		(( verbose >= 2 )) && log_msg "Checking installed packages"
		(( verbose >= 2 )) && sh_cabec "$nfiles"

   	for item in "${aCache[@]}"; do
			[[ -z "$item" ]] && continue;
 	     	package=${item##*/}
			package=${package%.desc*}
			status=' I '
			clisting='N'
			LTABLE=$true
			(( LTABLE       )) && verbose=2
			(( verbose >= 2 )) && clisting=''

			if sh_ascanpkg "$package" '5'; then
				cbase="${aPKGARRAY[0]}"
				clineascan >> "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
				((++pkgNumber))
				if (( verbose >= 2 )); then
					sh_write "$cbase" '-1' $((pkgNumber)) "$status" "$clisting"
					printf " %b ${pink}(%d)${reset} %-100s\r" "${TICK}" "$((nfiles-pkgNumber))" "$cbase"
				else
					cline="$(sh_write "$cbase" '-1' $((pkgNumber)) "$status" "$clisting")"
					if [[ -n "$cline" ]]; then
						printf " %b ${pink}(%d)${reset} %-200s\r" "${TICK}" "$((nfiles-pkgNumber))" "$cline"
					fi
				fi
			else
				log_msg "${yellow}WARNING ${cyan}package $package not found"
			fi
   	done
   	lresult=0
   fi
	log_msg "${yellow}($nfiles) ${cyan}packages found            - (old packages removed manual?)"
	log_msg "${yellow}($pkgNumber) ${cyan}packages installed/listed - (use -Sr --verbose for listing)"
	return $lresult
}

# -Qq
sh_totalpackagesinstalled() {
	if (( verbose >= 2 )); then
		awk -F "," '{print $1}' "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
	else
		sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
	fi
}

sh_listforinstall() {
#	local param="$@"
	local param="$*"
	local pkgNumber=0
	local s
	local LLIST=$true
	local LEXACT=$false
	local LALL=$false
	local LDEPS=$true
	local ncontapkg=0
	local cListSearch
	local arr

	[[ -e "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" ]] || printf '' > "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
	public_ntotal_pkg_installed=$(sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT")
	public_ntotal_pkg_listed="$public_ntotal_pkg_installed"
	public_pkg=()

	for s in "${param[@]}"; do
		cListSearch+="$s "
	done

	if (( LALL )) || [[ -z "$cListSearch" ]]; then
		if (( LALL )); then
			public_pkg=("$(grep ^ "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | cut -d"$SEP" -f5)")
		else
			log_msg $ERR_ERROR "${red}error${reset}: nenhum alvo definido (use -h para obter ajuda)"
			exit 1
		fi
	else
		for x in $cListSearch; do
			if (( LEXACT )); then
				if [[ "$SPLITPOS" == "0" ]]; then
#					public_pkg="$public_pkg $(grep ^"$x": "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | cut -d"$SEP" -f1)"
					public_pkg+=("$(grep ^"$x": "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | cut -d"$SEP" -f1)")
				else
#					public_pkg="$public_pkg $(grep ^"$x": "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | cut -d"$SEP" -f5)"
					public_pkg+=("$(grep ^"$x": "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | cut -d"$SEP" -f5)")
				fi
			else
				if [[ "$SPLITPOS" == "0" ]]; then
#					public_pkg="$public_pkg $(grep "$x" "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | cut -d"$SEP" -f1)"
					public_pkg+=("$(grep "$x" "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | cut -d"$SEP" -f1)")
				else
#					public_pkg="$public_pkg $(grep "$x" "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | cut -d"$SEP" -f5)"
					public_pkg+=("$(grep "$x" "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | cut -d"$SEP" -f5)")
				fi
			fi
		done
	fi

	if (( LLIST )); then
   	arr=("${public_pkg[*]}")
   	ncontapkg=${#arr[*]}
		if [[ "${#public_pkg}" -gt 0 ]]; then # pacote?
			pkgNumber=0
  			sh_getdeps $LDEPS
      	arr=("${public_pkg[*]}")
      	ncontapkg=${#arr[*]}
			public_ntotal_pkg_listed=$ncontapkg
		else
			log_msg "($pkgNumber) package(s) found."
			echo
			echo -e "${reset}Use: # ${APP} -Sy - to update with the repository${reset}"
		fi
	else
		pkgNumber=0
		for i in ${public_pkg[@]}; do
			((pkgNumber++))
		done
		public_ntotal_pkg_listed="$pkgNumber"
	fi
	sh_cdroot
	return $pkgNumber
}

sh_list_archives_directories()
{
	local packname="${1}.list"
	local LIST_CLEAN_DIRECTORIES

	sed -i "
        s/^\.\///g
        s/^\///g
        s|\/$||g
        /^\./d
        /^ *$/d
        /^bin$/d
        /^info$/d
        /^boot$/d
        /^dev$/d
        /^etc$/d
        /^home$/d
        /^lib$/d
        /^lib64$/d
        /^media$/d
        /^mnt$/d
        /^opt$/d
        /^proc$/d
        /^root$/d
        /^run$/d
        /^sbin$/d
        /^srv$/d
        /^sys$/d
        /^tmp$/d
        /^usr$/d
        /^var$/d
        /^info\/pos\.sh$/d
        /^info\/pre\.sh$/d
        /^info\/desc/d
        /info\/rm.sh/d
        /^var\/lib\/banana\/list\/.*\.list/d
        /^var\/lib$/d
        /^var\/lib\/banana/d
        /^var\/lib\/banana\/list/d
        /^var\/lib\/banana\/remove/d
	" "${CACHEDIR_LIST}/${packname}"

	LIST_CLEAN_DIRECTORIES=(
		'var'
		'lib'
		'media'
		'usr'
		'usr/share'
		'srv'
	)

	while read -r view; do
		if [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[0]}/(cache|lib|local|lock|log|mail|opt|run|spool|tmp)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${CACHEDIR_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[1]}/(lib64)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${CACHEDIR_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[2]}/(cdrom|floppy)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${CACHEDIR_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[3]}/(bin|etc|lib|lib\/(pkgconfig)|local|share|doc|include|libexec|sbin|src)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${CACHEDIR_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[4]}/(keymaps|fonts|pixmaps|applications|doc|man|man\/man[[:digit:]]+|man\/.{2})$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${CACHEDIR_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[5]}/(www|httpd)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^${view}$/d" "${CACHEDIR_LIST}/${packname}"
		fi
	done < "$CACHEDIR_LIST/$packname"
}

sh_manage_scripts_and_archives() {
   local packname=${aPKGSPLIT[$PKG_BASE_VERSION]}
	local dir_desc="${CACHEDIR_LIST/list/desc}"

	if ! [[ -e "/tmp/info/desc" ]]; then
		log_msg $ERR_ERROR "ERROR! /info/desc does not exist. ABORT!"
		return 1
	fi

	pushd "/tmp/info/" >/dev/null 2>&- || return 1
	if ! mv '/tmp/info/desc' "$CACHEDIR_DESC/${packname}.desc" ; then
		log_msg $ERR_ERROR "ERROR! could not move desc to /${dir_desc}/${packname}.desc"
		return 1
	fi

	if [[ -e "/tmp/info/pos.sh" ]]; then
		log_msg "running pos.sh hook"
		bash "/tmp/info/pos.sh"
	fi

	if [[ -e "/tmp/info/.INSTALL" ]]; then
		source /tmp/info/.INSTALL >/dev/null 2>&-
		log_msg "running post_install hook"
		post_install >/dev/null 2>&-
		log_msg "running post_upgrade hook"
		post_upgrade >/dev/null 2>&-
	fi

	if [[ -e "/tmp/info/rm.sh" ]]; then
		if ! mv '/tmp/info/rm.sh' "$CACHEDIR_REMO/${packname}.rm" ; then
			log_msg $ERR_ERROR "ERROR! could not move rm.sh to $CACHEDIR_REMO/${packname}.rm"
			return 1
		fi
    fi

	popd >/dev/null 2>&- || return 1
	[[ -d "/info/"      ]] && rm -r "/info/"
   [[ -d '/tmp/info/'  ]] && rm -r "/tmp/info/"
   [[ -e '/.BUILDINFO' ]] && rm "/.BUILDINFO"
   [[ -e '/.MTREE'     ]] && rm "/.MTREE"
   [[ -e '/.PKGINFO'   ]] && rm "/.PKGINFO"
   [[ -e '/.INSTALL'   ]] && rm "/.INSTALL"
	return 0
}

sh_create_list() {
	local packname="$1"

	if ! tar	--use-compress-program=zstd --force-local --list --file "$packname" > "${CACHEDIR_LIST}/${name_version_build}.list"; then
		log_msg $ERR_ERROR "ERROR! Can not create ${CACHEDIR_LIST}/${name_version_build}.list"
		return 1
	fi
	return 0
}

sh_input_null_parameter() {
	local arr
	local cpkg="$1"

	if [[ -z "$cpkg" ]]; then
		cpkg=$(echo "$PWD" | sed 's/\// /g' | awk '{print $NF}'|sed 's/-/_/g'| sed 's/\(.*\)_/\1 /'|sed 's/ /-/g')
		arr=("$cpkg")
		[[ ${#arr[*]} -gt 2 ]] && cpkg="${arr[0]}_${arr[1]} ${arr[2]}"
		cpkg=${cpkg}-${DESC_BUILD}
	fi
	sh_info "INPUT_NULL" "$cpkg"
	return 0
}

sh_name_format_pkg() {
	local packname="$1"

	re="\b${PKG_EXT}\b"
	if ! [[ "$packname" =~ .*\.${re}$ ]]; then
		log_msg $ERR_ERROR "ERROR Package need finish .${PKG_EXT}"
		return 1
	fi
	return 0
}

sh_generate_desc() {
	local i
	local DESC_PACKNAME=$1
	local DESC_VERSION=$2
	local DESC_BUILD=$3
   local field_pkgver=$4
   local field_pkgrel=$5
	#DESC=$(echo "${DESC//\'}") 		# remove apostrofe. ex: let´s => lets
	DESC=${DESC//\'} 						# remove apostrofe. ex: let´s => lets

	[[ ! -d "info" ]] && mkdir info >/dev/null 2>&-

	if [ -e info/desc ]; then
		(( ncount++ ))
		if ! (( LFORCE )); then
			if (( verbose >= 2 )); then
				log_msg "$(fmt)${orange} info/desc ${reset}already exist. Skipping... Use the -f option to force recreate."
			fi
			return
		else
			if (( verbose >= 2 )); then
				log_msg "$(fmt)${orange} info/desc ${reset}already exist. Rewriting"
			fi
		fi
	fi
	[[ -z "$SIZE" ]] && SIZE=$(sizeof_du .)

	cat > "info/desc" << EOF
######################################################################
# Generated with fetch    - https://chililinux.com
# Generated with alienpkg - https://chililinux.com
######################################################################
maintainer='$MAINTAINER'
pkgname='$DESC_PACKNAME'
version='$DESC_VERSION'
build='$DESC_BUILD'
pkgver='$field_pkgver'
pkgrel='$field_pkgrel'
license='$LICENSE'
lfs_version='$LFS_VERSION'
lfs_init='$LFS_INIT'
arch='$ARCH'
distro='$DISTRO'
desc='$DESC'
pkgdesc='$DESC'
size='$SIZE'
url='$URL'
source=('')
dep=('')
EOF

	for i in ${deps[@]}; do
		echo depend="'$i'" >> "$DESCME"
	done
	return 0
}

sh_doinstallpkg(){
	(
	local packname="$1"
	local name_version_build
	local PRE_SH='info/pre.sh'
	local INSTALL_SH='info/.INSTALL'

	tar --dereference                      \
				--force-local                 \
				--use-compress-program=zstd   \
				--extract                     \
				--preserve-permissions        \
				--touch                       \
				--file "${packname}" -C "/tmp/" "./${DESCME}" "./${PRE_SH}" "./${INSTALL_SH}" >/dev/null 2>&-

	if [[ ! -e "/tmp/${DESCME}" ]]; then
		log_msg $ERR_ERROR "${red}ERROR! ${reset}I could not untar the file: ${orange}${packname}.desc${reset}"
#		return 1
	fi
#	source "/tmp/${DESCME}" ||	log_msg $ERR_ERROR "ERROR! could not load /tmp/${DESCME}. Archive not exist. ABORT!"
	if [[ -e "/tmp/${DESCME}" ]]; then
		source "/tmp/${DESCME}"
	fi

	if [[ -e "/tmp/${PRE_SH}" ]]; then
		log_msg "running pre.sh hook"
		bash "/tmp/${PRE_SH}"
	fi

	if [[ -e "/tmp/${INSTALL_SH}" ]]; then
		log_msg "running .INSTALL hook"
		bash "/tmp/${INSTALL_SH}"
	fi

	#name_version_build="${pkgname}-${version}-${build}"
	sh_splitpkg "$packname"
	name_version_build=${aPKGSPLIT[$PKG_BASE_VERSION]}
	tar 	--dereference 						\
			--force-local 						\
			--use-compress-program=zstd	\
			--extract 							\
			--preserve-permissions 			\
			--touch 								\
			--file "${packname}" -C / | tee -a "$CACHEDIR_LIST/$name_version_build.list" || return 1

	sh_create_list "$1" || return 1
#	sh_manage_scripts_and_archives "${packname}" || return 1
	sh_list_archives_directories "${name_version_build}"
	)
	return "$?"
}

# -Sl
sh_initinstallpkg() {
#	local param="$@"
	local param="$*"
	local pkg
	local package
	local arr
	local nfiles

	if ! (( LALL )); then
		test $# -lt 1 && die "Missing value for the required argument '$param'. ${yellow}Try ${0##*/} -Sl <package>" 1; _arg_unit="$2"
	fi

	shopt -s nullglob       # enable suppress error message of a command
	if (( LALL )); then
		pkg="$pkg $(find "$PWD/" "$CACHEDIR_ARCHIVES/" -type f -iname "*.$PKG_EXT")"
	else
		for s in "${param[@]}"; do
			cfile=$(echo "$s" | sed 's/\// /g' | awk '{print $NF}')
			pkg="$pkg $(find "$PWD/" "$CACHEDIR_ARCHIVES/" -type f -iname "*.$PKG_EXT" | grep "$cfile")"
		done
	fi

	pkgCheckNumber=0
	LLIST=$true
	arr=("${pkg[*]}")
	nfiles=${#arr[*]}

	if (( nfiles )); then # pacote?
		for i in $pkg; do
			(( LLIST )) && log_success_msg2 "${blue}FOUND local package ${orange}$i"
			((pkgCheckNumber++))
		done

		if (( pkgCheckNumber )); then
			if ! (( LAUTO )); then
				conf "$(DOT)continue installation?"
				LAUTO=$?
			fi
		fi

		if (( LAUTO )); then
			for package in $pkg
			do
				log_wait_msg "Installing local package ${orange}$package"
				sh_installpkg "$package"
			done
		fi
	else
		msg "${orange}$param ${red}NOT FOUND ${reset}local package in ${orange}${CACHEDIR_ARCHIVES}${reset}"
		msg "${orange}$param ${red}NOT FOUND ${reset}local package in ${orange}${PWD} ${reset}"
		printf '%s\n' "${reset}Use: ${0##*/} -Sy to update with the repository${reset}"
	fi
	shopt -u nullglob       # disable suppress error message of a command
}

sh_installpkg() {
	local cfileinstalled
	local fullname
	local package

	while [[ -n "$1" ]]; do
		fullname="$1"
		package="${fullname##*/}"  				## tira o path
		sh_doinstallpkg "$fullname" || return $ERR_ERROR
		sh_splitpkg "$fullname" || return $ERR_ERROR
		cfileinstalled=${aPKGSPLIT[$PKG_BASE_VERSION]}
		cline=$(clinesplit)
		sed -i '/'"$cfileinstalled"'/d' "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" || return $ERR_ERROR
		echo "${cline}" >> "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
		shift
	done
	return $ERR_OK
}

sh_sign_gpg() {
	local package=$1
	local sig='sig'

	#Pacote existe?
	if [[ ! -e "${package}.${PKG_EXT}" ]]; then
		printf '%s\n' "${red}[ERRO]${end} Unable to sign package. ${package}.${PKG_EXT}"
		printf '%s\n' "Reason: Package not found."
		printf '%s\n' "For security reasons, do not pass the package on to third parties."
		return 1
	fi

	[ "$REWRITE_SIGN" = "1" ] && rm -f "../$package.$PKG_EXT.$sig"
	[ "$REWRITE_SIGN" = "1" ] && rm -f "$package.$PKG_EXT.$sig"

	if which gpg >/dev/null 2>&-; then
		#Gerando Assinatura no pacote
		gpg --detach-sign --pinentry-mode loopback "${package}.${PKG_EXT}" >/dev/null 2>&- || \
		gpg --detach-sign "${package}.${PKG_EXT}" || return 1
		echo -e "${blue}[Create]${end} Your ${sig} on:   ../${package}.${PKG_EXT}.${sig}"
	fi
	return 0
}

sh_verify_on() {
	local package=$1
	local dir_info='info'
	local info_desc='desc'

	if [[ ! -d "$dir_info" ]]; then
		log_msg $ERR_ERROR "${red}[ERROR!]${end} ${pink}${dir_info}${end} directory\n"
		log_msg $ERR_ERROR "It's necessary your package have the DIRECTORY ${pink}info${end}."
		log_msg $ERR_ERROR "${pink}${dir_info}${end} its a directory store important archives."
		log_msg $ERR_ERROR "For more information use -h, --help."
		exit 77
	elif [[ ! -e "${dir_info}/${info_desc}" ]]; then
		log_msg $ERR_ERROR "${red}[ERROR!]${end} ${pink}${info_desc}${end} archive\n"
		log_msg $ERR_ERROR "It's necessary your package have the ARCHIVE ${pink}desc${end} inside of directory '${dir_info}'."
		log_msg $ERR_ERROR "${pink}${info_desc}${end} have informations of your package."
		log_msg $ERR_ERROR "For more information use -h, --help."
		exit 1
	else
		source "$dir_info/$info_desc"

		if [[ -z "$maintainer" ]]; then
			log_msg $ERR_ERROR "Check ${pink}${info_desc}${end}, VARIABLE ${blue}maintainer${end} null"
			log_msg $ERR_ERROR "Enter the name of the package maintainer into variable maintainer."
			#exit 1
		elif [[ -z "$pkgname" ]]; then
			log_msg $ERR_ERROR "Check ${pink}${info_desc}${end}, VARIABLE ${blue}pkgname${end} null"
			log_msg $ERR_ERROR "Enter the name of the package into variable pkgname."
			#exit 1
		elif [[ -z "$version" ]]; then
			log_msg $ERR_ERROR "Check ${pink}${info_desc}${end}, VARIABLE ${blue}version${end} null"
			log_msg $ERR_ERROR "Enter a version of software into variable version."
			#exit 1
		elif [[ -z "$build" ]]; then
			log_msg $ERR_ERROR "Check ${pink}${info_desc}${end}, VARIABLE ${blue}build${end} null"
			log_msg $ERR_ERROR "Enter the build number of package."
			#exit 1
		elif [[ -z "$desc" ]]; then
			log_msg $ERR_ERROR "Check ${pink}${info_desc}${end}, VARIABLE ${blue}desc${end} null"
			log_msg $ERR_ERROR "Detail a small description into variable desc."
			#exit 1
		elif [[ -z "$url" ]]; then
			log_msg $ERR_ERROR "Check ${pink}${info_desc}${end}, VARIABLE ${blue}url${end} null"
			log_msg $ERR_ERROR "Enter a url of project/software into variable url."
			#exit 1
      fi
   fi

	for check_script in 'pre.sh' 'pos.sh' 'rm.sh'; do
		if [[ -e "${dir_info}/${check_script}" ]]; then
	   	if _GREP 'rm[[:space:]]+\-(rf|fr)' "${dir_info}/${check_script}" >/dev/null 2>&-; then
		   	log_msg $ERR_ERROR "${red}ERROR ${reset}${PWD}/${dir_info}/$check_script contain command rm -rf. ABORTED NOW."
   			return 1
      	fi
   	fi
   done
	return "$?"
}

sh_create_pkg() {
	local package=$1
	local ext_desc='desc'

	if tar --force-local --use-compress-program="zstd --ultra" --create --file ../"$package" .; then
		cp "$DESCME" ../"$package.$ext_desc" >/dev/null 2>&-
		pushd .. >/dev/null 2>&- || return 1
		if (( CREATE_SHA256 )); then
			sha256sum "$package" > "$package".sha256
		fi
		if (( GPG_SIGN )); then
			sh_sign_gpg "$package" || return 1
			popd >/dev/null 2>&- || return 1
		else
			return 0
		fi
	fi
	evaluate_retval
}

sh_generatepkg() {
#	local param="$@"
	local param="$*"

	if [[ ${#param} -eq 0 ]]; then # run standalone
		LAUTO=$true
		LLIST=$false
		pkg="${PWD##*/}.$PKG_EXT"
	else
		for s in "${param[@]}"; do	pkg="$s"; continue; done
	fi

	((++ncount))
	(( verbose >= 1 )) && log_msg "$(fmt) Generating info for package $pkg"
	[[ ! -e "info/desc" ]] && LFORCE=$true

	if (( LAUTO )) || (( LFORCE )); then
		if [[ -z "$DESC_PACKNAME" ]]; then
			sh_splitpkg "$pkg"
			field_pkgname="${aPKGSPLIT[$PKG_BASE]}"
			field_pkgver="${aPKGSPLIT[$PKG_VERSION]}"
			field_version="${aPKGSPLIT[$PKG_VERSION]}"
			field_pkgrel="${aPKGSPLIT[$PKG_BUILD]}"
			field_build="${aPKGSPLIT[$PKG_BUILD]}"
	    else
    		field_pkgname="${DESC_PACKNAME}"
    		field_pkgver="${DESC_VERSION}"
    		field_version="${DESC_VERSION}"
	    	field_pkgrel="${DESC_BUILD}"
	    	field_build="${DESC_BUILD}"
	   fi
	   [[ -z "$field_build" ]] && field_build="$DESC_BUILD"
		[[ -z "$DESC"        ]] && DESC="$field_pkgname-$field_version"

		sh_generate_desc "$field_pkgname" "$field_version" "$field_build" "${field_pkgver::-2}" "$field_pkgrel" || return $ERR_ERROR
	fi
	return $ERR_OK
}

sh_createpkg() {
#  local param="$@"
   local param="$*"
	local s
	local pkg

	for s in "${param[@]}"; do pkg="$s"; done
	[[ -z "$pkg" ]] 		&& pkg=$(echo "$PWD" |sed 's/\// /g'|awk '{print $NF}')
	(( verbose >= 1 )) 	&& log_msg "$(fmt) Building package $pkg"

	pkg="$pkg.$PKG_EXT"
	sh_generatepkg "$pkg"
   sh_name_format_pkg "$pkg" || exit 1
   sh_verify_on "$pkg" || exit 1
	sh_create_pkg "$pkg" || exit 1
	((++ncount))
	(( verbose >= 1 )) && log_msg "$(fmt) Generating package ${yellow}$pkg"
}

# -Sa
sh_alienpkg_main() {
	sh_alienpkg_initvars "$*"
	sh_alienpkg_exec "$*"
}

sh_alienpkg_initvars() {
	BUILDDIR="${PKGCORE:=${CACHEDIR}/archives}"
	[[ -n "${BUILDDIR}" ]] || BUILDDIR="${CACHEDIR}/archives" >/dev/null 2>&-
	[[ -d "${BUILDDIR}" ]] || mkdir -p "${BUILDDIR}" >/dev/null 2>&-
}

function sh_alienpkg_exec() {
	local param="$*"
	local pkg
	local package
	local LFORCELOCAL
	local string
	local ntotalpkg=0
	local ntotalfindpkgs=0
	local ncount=0
	local arraypkg
	local npackagesprocessed=0
	local firstletter
	local FilteredPackage
	local destpkgGIT
	local destpkgCORE
	export deps

	if [[ -z "$param" ]]; then
		LALL=$true
	else
		LALL=$false
  		for s in "${param[@]}"; do	string+="$s";	done
  	fi

	if (( LALL )); then
		if ! (( LTIME )); then
			mapfile -t pkg < <(find "$ALIEN_CACHE_DIR/" -regextype posix-egrep -regex "$RE_ALIEN" -type f)
		else
			mapfile -t pkg < <(find "$ALIEN_CACHE_DIR/" -regextype posix-egrep -regex "$RE_ALIEN" -type f -mtime "$mtime")
		fi
	else

  		for str in $string; do
			if ! (( LTIME )); then
				if (( LEXACT )); then
					pkg+=( "$(find "$ALIEN_CACHE_DIR/" -regextype posix-egrep -regex "$ALIEN_CACHE_DIR/$str$RE_ALIEN" -type f)")
				else
					pkg+=("$(find "$ALIEN_CACHE_DIR"/ -iname "*$str*" -regextype posix-egrep -regex "$RE_ALIEN" -type f)")
				fi
			else
				pkg+=("$(find "$ALIEN_CACHE_DIR"/ -iname "*$str*" -regextype posix-egrep -regex "$RE_ALIEN" -type f -mtime "$mtime")")
			fi
		done
	fi

	ntotalpkg=${#pkg[*]}
	ntotalfindpkgs=$ntotalpkg
	LFORCELOCAL=$LFORCE

	if (( ntotalpkg )); then # package found?
		for package in ${pkg[@]}
		do
			ncount=0
			pkgtar=${package##*/}                #remove diretorio deixando somente nome do pacote
			pkgtar=${pkgtar%%.pkg.tar.zst}       #remove .tar.zst ext
			pkgtar=${pkgtar%%.pkg.tar.xz}        #remove .tar.xz ext
			! (( CHILI_OS )) && pkgtar=${pkgtar%%-any}
			! (( CHILI_OS )) && pkgtar=${pkgtar%%-x86_64}
			cPacoteSemExt=${pkgtar%%.*}          # https://elmord.org/blog/?entry=20121227-manipulando-strings-bash
			cPacoteSemExt=${cPacoteSemExt%-*}    # https://elmord.org/blog/?entry=20121227-manipulando-strings-bash

			if ! (( LFORCELOCAL )); then
				firstletter=${pkgtar::1}
				FilteredPackage=$pkgtar.$PKG_EXT
				destpkgGIT="${LOCALDIR}/packages/${firstletter}/${FilteredPackage}"
				destpkgCORE="${LOCALDIR}/packages/core/${FilteredPackage}"

				if [[ -e "$destpkgGIT" || -e "$destpkgCORE" ]]; then
					(( verbose >= 2 )) && log_msg $ERR_ERROR "$(fmt) ${orange}$FilteredPackage ${reset}Package already exist in ${green}$LOCALDIR/packages/$firstletter/${reset} Use the -f option to force rebuild."
					(( --ntotalpkg ))
					continue
				fi
			fi

			destdir="$BUILDDIR/$pkgtar"
			(( ++ncount ))
			(( verbose >= 1 )) && log_msg "$(fmt) Creating directory $destdir"
			mkdir -p "$destdir" >/dev/null 2>&-

			(( ++ncount ))
			(( verbose >= 1 )) && log_msg "$(fmt) Unpacking package $package at $destdir"
			tar --use-compress-program=zstd --force-local --extract --file "$package" -C "$destdir" >/dev/null 2>&-

			case $package in
				luit-[0-9]* ) sed -i -e "/D_XOPEN/s/5/6/" configure;;
			esac

			sed -i 's/ = /="/g' "$destdir/.PKGINFO"  >/dev/null 2>&-
			sed -i 's/$/"/g'    "$destdir/.PKGINFO"  >/dev/null 2>&-
			source "$destdir/.PKGINFO" >/dev/null 2>&-

			export          DESC_BUILD="${pkgtar: -1}"
			export                 URL="$url"
			export             LICENSE="$license"
			export                ARCH="$arch"
			export                SIZE="$size"
			export                DESC="$pkgdesc"
			export                 DEP="$depend"
			export       DESC_PACKNAME="$pkgname"
			export        DESC_VERSION="$pkgver"
			export          DESC_BUILD="${pkgver: -1}"

			deps=$(grep ^depend "$destdir"/.PKGINFO | awk -F'"' '{print $2}')
			pushd "$destdir" >/dev/null 2>&- || return 1
			rm -f "$destdir"/.BUILDINFO "$destdir"/.MTREE "$destdir"/.PKGINFO >/dev/null 2>&-

			(( ++ncount ))
			sh_createpkg "$pkgtar"
			(( verbose >= 1 )) && echo
			(( --ntotalpkg ))
			(( ++npackagesprocessed ))
		done

		(( verbose >= 1 )) && log_msg "Total alien packages found     : $ntotalfindpkgs"
		(( verbose >= 1 )) && log_msg "Total alien packages processed : $npackagesprocessed  ${green}Use the --force option to force rebuild."

		if ! (( LKEEP )); then
			(( ++ncount ))
#			(( verbose >= 1 )) && log_msg "Verifying candidate packages files for pruning"
#			removeoldpkgchili $cPacoteSemExt
#			fetchpack -q -c "$LOCALDIR/packages/" -m /tmp/ "$cPacoteSemExt"
#			fetchpack_init -k1 -r
		fi
	else
		log_msg $ERR_ERROR "${red}error: ${orange}$x ${reset}package target ${yellow}${param} ${reset}was ${red}NOT ${reset}found in ${yellow}${ALIEN_CACHE_DIR} ${reset}for import"
	fi
	unset size ncount ntotalpkg
	popd >/dev/null 2>&- || return 1
}

sh_alienpkg_pkgsize() {
	size="$(du -sk --apparent-size)"
	size="$(( ${size%%[^0-9]*} * 1024 ))"
}

sh_alienpkg_logo() {
	cat << 'EOF'
       _ _                  _
  __ _| (_) ___ _ __  _ __ | | ____ _
 / _` | | |/ _ \ '_ \| '_ \| |/ / _` |
| (_| | | |  __/ | | | |_) |   < (_| |
 \__,_|_|_|\___|_| |_| .__/|_|\_\__, |
                     |_|        |___/
EOF
	sh_version
}

sh_upgrade() {
#	local param="$@"
	local param="$*"
	local LLIST=$false
	local count=0
	local s
	local item
	local cBaseInstalled cBaseVersionInstalled cVersionInstalled
	local	cBase cBaseVersion cVersion
	local ntotalconfered
	local pkgrepo
	local ntotal_pkg_listed

	(( verbose > 1 )) || verbose=0
	LDEPS=$false
	LEXACT=$true
	LLIST=$false
	sh_listpkgdisp	"$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" "$param"

	local ntotal_pkg_listed=${public_ntotal_pkg_listed}

	for i in ${public_pkg[@]}; do
		sh_splitpkg "$i"
		cBaseInstalled="${aPKGSPLIT[PKG_BASE]}"
		cBaseVersionInstalled="${aPKGSPLIT[PKG_BASE_VERSION]}"
		cVersionInstalled="${aPKGSPLIT[PKG_VERSION]}"
		pkgrepo=$(grep ^"$cBaseInstalled$SEP" "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | cut -d"$SEP" -f4)
		count=0
		((ntotalconfered++))

		if [[ "${#pkgrepo}" -gt 0 ]]; then # pacote?
			for cPkg in ${pkgrepo}; do
				sh_splitpkg "$cPkg"
				cBase="${aPKGSPLIT[PKG_BASE]}"
				cBaseVersion="${aPKGSPLIT[PKG_BASE_VERSION]}"
				cVersion="${aPKGSPLIT[PKG_VERSION]}"

				case "$cBase" in
					Python) continue;;
					gtk+)   continue;;
				esac

				if [[ "$cBaseInstalled" == "$cBase" ]]; then
					((count++))
					if [[ "$(vercmp "$cBaseVersionInstalled" "$cBaseVersion")" -lt 0 ]]; then
						log_success_msg2 "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBase} ${reset}is being updated to newest version ($cVersion)."
						sh_doremove "$cBaseVersionInstalled" "OFF"
						LAUTO=$true; LFORCE=$true; LDEPS=$false; sh_install "$cBase"
					elif [[ "$cBaseVersionInstalled" = "$cBaseVersion" ]]; then
						if (( LFORCE )); then
							LAUTO=$true; LFORCE=$true; LDEPS=$false; sh_install "$cBase"
							continue
						else
							log_success_msg2 "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBase} ${reset}is already the newest version ${green}($cVersionInstalled)${reset}. Use the -f option to force reinstallation."
							continue
						fi
					else
						if (( LFORCE )); then
							LAUTO=$true; LFORCE=$true; LDEPS=$false; sh_install "$cBase"
						else
							log_success_msg2 "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBase} ${reset}is already the newest version ($cVersionInstalled)."
						fi
						if (( count > 1 )); then
							log_warning_msg "${orange}${cBaseInstalled} ${red}WARNING!! there is more than one release of the package in the repo!"
						fi
					fi
				else
   	 			log_warning_msg "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBase} ${reset}not installed."
				fi
			done
		else
			log_warning_msg "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBaseInstalled} ${red}WARNING!! package not in repo! Use 'fetch update' to update the database"
		fi
	done

	if [[ "${#public_pkg}" -le 1 ]]; then # nenhum pacote?
		log_warning_msg "$orange$param$cyan package not installed"
		echo
		if conf "${blue}:: ${reset}Install Pakages(s)?"; then
			LAUTO=$true; LFORCE=$true; LDEPS=$false; sh_install "$param"
		fi
	fi
	sh_cdroot
}

checkDependencies() {
	local d
   local errorFound=0
   declare -a missing

   for d in "${DEPENDENCIES[@]}"; do
      [[ -n $(command -v "$d") ]] && { :; } || { log_msg "ERROR: Could not find command ${cyan}'$d'${reset}"; missing+=("$d"); errorFound=1; }
   done
   if (( errorFound )); then
		echo "${yellow}---------------IMPOSSIBLE TO CONTINUE---------------"
    	echo "${black}This script needs the commands listed above"
    	echo "Install them and/or make sure they are in your \$PATH"
    	echo "${yellow}---------------IMPOSSIBLE TO CONTINUE---------------"
		exit 1
  fi
}

sh_cleaning() {
	log_msg "${pink}Cleaning temporary files${reset}"
	rm -rf "${TMP_DIR_ROOT:?}"/ >/dev/null 2>&-
}

sh_backup() {
	if (( verbose >= 2 )); then
		log_msg "${pink}Making backup: $CACHEDIR_SEARCH/${reset}"
	fi
	mkdir -p "$TMP_DIR_BACKUP" >/dev/null 2>&-
	mkdir -p "$TMP_DIR_FOLDERS" >/dev/null 2>&-
	cp -f "$CACHEDIR_SEARCH/*" "$TMP_DIR_BACKUP/" >/dev/null 2>&-
}

sh_version() {
	orange=$(tput setaf 166);
	printf "%s\n" "${orange}${0##*/} v${_VERSION_}"
}

#figlet
logo() {
	cat << 'EOF'
  __      _       _
 / _| ___| |_ ___| |__     Copyright (c) 2019-2022 Vilmar Catafesta <vcatafesta@gmail.com>
| |_ / _ \ __/ __| '_ \    Copyright (c) 2019-2022 Chili GNU/Linux Development Team <root@chililinux.com>
|  _|  __/ || (__| | | |
|_|  \___|\__\___|_| |_|   Este programa pode ser redistribuído livremente
                           sob os termos da Licença Pública Geral GNU.
EOF
	sh_version
}

fetchpack_configure() {
	#  fetchpack - A flexible cache cleaning utility in ChiliOS
	#########################################################################
	declare -a cachedirs=() candidates=() cmdopts=() candesc=()
	declare -i delete=0 dryrun=0 move=0 totalsaved=0 pkgcount=0
	declare -i verbose=0 ctime=0 QUIET=0
	declare delim=$'\n'
	declare keep=1
	declare movedir=
	declare USE_COLOR='y'
	# Expand to nothing if there are no matches
	shopt -s nullglob
	shopt -s extglob
}

fetchpack_main() {
	local nfiles=0
	local pkg
	local pkgInAll
	local pkg_base
	local candidates=()
	local cachedir
	local re="$FETCH_RE"

	if (( QUIET )); then
		verbose=0
	else
		if (( verbose )); then
			if (( dryrun )); then
		   	log_msg "${white}running mode => ${green}DRY-RUN"
			elif (( delete )); then
		   	log_msg "${white}running mode => ${red}DELETE"
			elif (( move )); then
		   	log_msg "${white}running mode => ${yellow}MOVE"
			fi
		fi
	fi

	for cachedir in "${cachedirs[@]}"
	do
		[[ -d $cachedir ]]            || { log_msg $ERR_ERROR "${red}Error: cachedir '$cachedir' does not exist or is not a directory -- skipping"; continue; }
		pushd "$cachedir" &>/dev/null || die "Error: failed to chdir to $cachedir"

		if [ $# -lt 1 ]; then
 			AllOldPackages=$(find "$PWD" -type f -iname "*.$PKG_EXT" | sort -Vr | awk -F "$re" 'lista[$1]++')
		else
 			AllOldPackages=$(find "$PWD" -type f -iname "*.$PKG_EXT" | grep "$1" | sort -Vr | awk -F "$re" 'lista[$1]++')
		fi

		while read -r pkgInAll; do
			pkg_base="$pkgInAll"
			[[ -z "$pkg_base" ]] &&	continue
			((++pkgNumber))

			if (( verbose >= 3 )); then
				printf "  $(DOT)${white}candidate package ${purple}(%04d) ${green}%s\n" "$pkgNumber" "$pkg_base"
			fi
			[[ -e "$pkgInAll"      ]] && candidates+=("$pkgInAll")
			[[ -e "$pkgInAll.desc" ]] && candesc+=("$pkgInAll.desc")
		done <<< "$AllOldPackages"  #done < <(printf '%s\n' "$AllOldPackages") #done <<< $(printf '%s\n' "$AllOldPackages")
		popd >/dev/null 2>&1
	done

	if (( ! ${#candidates[*]} )); then
		log_msg "${green}NO candidates packages found for pruning"
		return 1
	fi

	if (( verbose >= 2 )); then
		pkgNumber=0
		while read -r pkg; do
			((++pkgNumber))
			printf "  $(DOT)${white}found package ${purple}(%04d) ${green}%42s\n" "$pkgNumber" "$pkg"
		done <<< "$(printf '%s\n' "${candidates[@]}")"
		#done < <(printf '%s\n' "${candidates[@]}") #done <<< "${candidates[@]}"
	fi

	ncandidates=${#candidates[*]}
	ncandesc=${#candesc[*]}
	pkgcount=$((ncandidates + ncandesc))

	(( ncandidates )) && totalsaved=$(printf '%s\0' "${candidates[@]}" | xargs -0 stat -c %s | awk '{ sum += $1 } END { print sum }')
	(( ncandesc    )) && totalsaved+=$(printf '%s\0' "${candesc[@]}"   | xargs -0 stat -c %s | awk '{ sum += $1 } END { print sum }')
	set -o errexit # Exit immediately if a pipeline returns non-zero.

	if (( delete )); then
		(( verbose )) && cmdopts+=(-v); cmdopts+=(-f)
		(( ncandidates )) && printf '%s\0' "${candidates[@]}" | runcmd xargs -0 rm "${cmdopts[@]}"
		(( ncandesc    )) && printf '%s\0' "${candesc[@]}"    | runcmd xargs -0 rm "${cmdopts[@]}"
	elif (( move )); then
		(( verbose )) && cmdopts+=(-v); cmdopts+=(-f)
		(( ncandidates )) && printf '%s\0' "${candidates[@]}" | runcmd xargs -0 mv "${cmdopts[@]}" -t "$movedir"
		(( ncandesc    )) && printf '%s\0' "${candesc[@]}"    | runcmd xargs -0 mv "${cmdopts[@]}" -t "$movedir"
	elif (( verbose )); then
		(( ncandidates )) && printf '%s\0' "${candidates[@]}" | xargs -0 printf "  $(DOT)%s\n" "${cmdopts[@]}"
		(( ncandesc    )) && printf '%s\0' "${candesc[@]}"    | xargs -0 printf "  $(DOT)%s\n" "${cmdopts[@]}"
	fi

	if (( ! QUIET )); then
		if (( dryrun )); then
			msg "${yellow}finish dry-run (packages found: $ncandidates with .desc) (disk space saved: %s)" "$(size_to_human "$totalsaved")"
		else
			msg "(packages found: $ncandidates with .desc) (disk space saved: %s)" "$(size_to_human "$totalsaved")"
		fi
	fi
	return 0
}

fetchpack_usage() {
	cat <<EOF
${cyan}Usage: ${yellow}fetch -Sc <operation> [options] [targets...]${reset}

  Operations:
${red}     -d, --dryrun          ${reset}perform a dry run, only finding candidate packages.
${red}     -m, --move <dir>      ${reset}move candidate packages to "dir".
${red}     -r, --remove          ${reset}remove candidate packages.

  Options:
${red}     -c, --cachedir <dir>  ${reset}scan "dir" for packages. can be used more than once.
                           (default: read from /etc/fetch/fetch.conf).
${red}     -k, --keep <num>      ${reset}keep "num" of each package in the cache (default: 1).
${red}     -f, --force           ${reset}apply force to mv(1) and rm(1) operations.
${red}     -h, --help            ${reset}display this help message and exit.
${red}         --nocolor         ${reset}remove color from output.
${red}     -q, --quiet           ${reset}quiet output.
${red}     -v, --verbose         ${reset}increase verbosity. specify up to 3 times ([-v][-vv][-vvv]).

${cyan}most common use: ${yellow}fetch -Sc -k1 -r -v${reset}
EOF
}

function parseopts() {
	local shortopts=$1
	local opt
	local optarg
	local i
	local -a longopts=()
	local -a unused_argv=()

	shift
	while [[ $1 && $1 != '--' ]]; do
		longopts+=("$1")
		shift
	done
	shift

	longoptmatch() {
		local o longmatch=()
		for o in "${longopts[@]}"; do
			if [[ ${o%:} = "$1" ]]; then
				longmatch=("$o")
				break
			fi
			[[ ${o%:} = "$1"* ]] && longmatch+=("$o")
		done

		case ${#longmatch[*]} in
			1)
				# success, override with opt and return arg req (0 == none, 1 == required)
				opt=${longmatch%:}
#				if [[ $longmatch = *: ]]; then
				if [[ "${longmatch[*]}" = *: ]]; then
					return 1
				else
					return 0
				fi ;;
			0)
				# fail, no match found
				return 255 ;;
			*)
				# fail, ambiguous match
#				printf "${0##*/}: $(gettext "option '%s' is ambiguous; possibilities:")" "--$1"
				printf "%s %s\n" "${0##*/}: $(gettext "option '%s' is ambiguous; possibilities:")" "--$1"
				printf " '%s'" "${longmatch[@]%:}"
				printf '\n'
				return 254 ;;
		esac >&2
	}

	while (( $# )); do
		case $1 in
			--) # explicit end of options
				shift
				break
				;;
			-[!-]*) # short option
				for (( i = 1; i < ${#1}; i++ )); do
					opt=${1:i:1}

					# option doesn't exist
					if [[ $shortopts != *$opt* ]]; then
						printf "${0##*/}: $(gettext "invalid option") -- '%s'\n" "$opt" >&2
						OPTRET=(--)
						return 1
					fi

					OPTRET+=("-$opt")
					# option requires optarg
					if [[ $shortopts = *$opt:* ]]; then
						# if we're not at the end of the option chunk, the rest is the optarg
						if (( i < ${#1} - 1 )); then
							OPTRET+=("${1:i+1}")
							break
						# if we're at the end, grab the the next positional, if it exists
						elif (( i == ${#1} - 1 )) && [[ $2 ]]; then
							OPTRET+=("$2")
							shift
							break
						# parse failure
						else
#							printf "${0##*/}: $(gettext "option requires an argument") -- '%s'\n" "$opt" >&2
							printf "%s %s\n" "${0##*/}: $(gettext "option requires an argument") -- '%s'" "$opt"
							OPTRET=(--)
							return 1
						fi
					fi
				done
				;;
			--?*=*|--?*) # long option
				IFS='=' read -r opt optarg <<< "${1#--}"
				longoptmatch "$opt"
				case $? in
					0)
						# parse failure
						if [[ $optarg ]]; then
#							printf "${0##*/}: $(gettext "option '%s' does not allow an argument")\n" "--$opt" >&2
							printf "%s %s\n" "${0##*/}: $(gettext "option '%s' does not allow an argument")" "--$opt"
							OPTRET=(--)
							return 1
						# --longopt
						else
							OPTRET+=("--$opt")
						fi
						;;
					1)
						# --longopt=optarg
						if [[ $optarg ]]; then
							OPTRET+=("--$opt" "$optarg")
						# --longopt optarg
						elif [[ $2 ]]; then
							OPTRET+=("--$opt" "$2" )
							shift
						# parse failure
						else
#							printf "${0##*/}: $(gettext "option '%s' requires an argument")\n" "--$opt" >&2
							printf "%s%s\n"	"${0##*/}: $(gettext "option '%s' requires an argument")" "--$opt"
							OPTRET=(--)
							return 1
						fi
						;;
					254)
						# ambiguous option -- error was reported for us by longoptmatch()
						OPTRET=(--)
						return 1
						;;
					255)
						# parse failure
						printf "${0##*/}: $(gettext "invalid option") '--%s'\n" "$opt" >&2
						OPTRET=(--)
						return 1
						;;
				esac
				;;
			*) # non-option arg encountered, add it as a parameter
				unused_argv+=("$1")
				;;
		esac
		shift
	done

	# add end-of-opt terminator and any leftover positional parameters
	OPTRET+=('--' "${unused_argv[@]}" "$@")
	unset longoptmatch
	return 0
}

function runcmd() {
   if (( EUID != 0 )); then
      msg "Privilege escalation required"
      if sudo -v &>/dev/null && sudo -l &>/dev/null; then
         sudo "$@"
      else
         die 'Unable to escalate privileges using sudo'
      fi
   else
      "$@"
   fi
}

function msg() {
	local mesg=$1; shift
	printf "%s\n"	"${green}  =>${reset}${bold} ${mesg}${reset}" "$*"
}

fetchpack_init() {
#	sh_checkroot
#	checkDependencies
	fetchpack_configure

	OPT_SHORT=':a:c:dfhi:k:m:qrsuVvzt:'
	OPT_LONG=('arch:' 'cachedir:' 'dryrun' 'force' 'help' 'ignore:' 'keep:' 'move:' 'nocolor' 'quiet' 'remove' 'uninstalled' 'version' 'verbose' 'null' 'ctime:')

	if ! parseopts "$OPT_SHORT" "${OPT_LONG[@]}" -- "$@"; then
		return 1
	fi
	set -- "${OPTRET[@]}"
	unset OPT_SHORT OPT_LONG OPTRET

	while :; do
		case $1 in
			-t|--ctime)
				ctime="$2"
				: echo "$ctime"
				shift ;;
			-c|--cachedir)
				cachedirs+=("$2")
				shift ;;
			-d|--dryrun)
				dryrun=1 ;;
			-f|--force)
				cmdopts=(-f) ;;
			-h|--help)
				fetchpack_usage
				return;;
			-m|--move)
				move=1 movedir=$2
				shift ;;
			--nocolor)
				sh_unsetvarcolors
				USE_COLOR='n' ;;
			-q|--quiet)
				sh_unsetvarcolors
				QUIET=1 ;;
			-r|--remove)
				delete=1 ;;
			-V|--version)
				logo
				return ;;
			-v|--verbose)
				(( ++verbose )) ;;
			--)
				shift
				break 2 ;;
		esac
		shift
	done

	# check if messages are to be printed using color
	if [[ -t 2 && $USE_COLOR != "n" ]]; then
		sh_setvarcolors
	fi

	# setting default cachedirs
	if [[ -z "${cachedirs[*]}" ]]; then
		[[ -n "$LOCALDIR" ]] && cachedirs=("$LOCALDIR")
		cachedirs+=("/var/cache/fetch/archives")
	fi

	# sanity checks
	case $(( dryrun+delete+move )) in
		0) 	die "no operation specified (use -Sc -h for help)" ;;
		[^1]) die "only one operation may be used at a time" ;;
	esac

	[[ $movedir && ! -d $movedir ]] && die "destination directory '$movedir' does not exist or is not a directory!"

	if (( move || delete )); then
		# make it an absolute path since we're about to chdir
		[[ $movedir && ${movedir:0:1} != '/' ]] && movedir=$PWD/$movedir
#		[[ $movedir && ! -w $movedir ]] && needsroot=1
	fi

	fetchpack_main "$@"
}

usage() {
	tput sgr0; # reset colors
	bold=$(tput bold);
	reset=$(tput sgr0);
	red=$(tput setaf 124);
	yellow=$(tput setaf 136);
	pink=$(tput setaf 129);

	cat <<EOF
${cyan}Most used commands:
${red}  -h,  help           ${reset}- display this help and exit
${red}  -Sy, update         ${reset}- update list packages in the repository online. Need Internet
${red}  -S,  install        ${reset}- install packages
${red}  -Ss, search         ${reset}- search for packages
${red}  -Su, upgrade        ${reset}- upgrade packages
${red}  -Sw, download       ${reset}- only download the binary package into cache directory
${red}  -Sr, recreate       ${reset}- recreate database installed packages
${red}  -Sa, alienpkg       ${reset}- import package from ArchLinux
${red}  -Sg, generate       ${reset}- generate info package from source
${red}  -C,  create         ${reset}- build package
${red}  -Sl, local          ${reset}- install local package
${red}  -Sc, clean          ${reset}- erase downloaded packages files
${red}  -Sm, meta           ${reset}- install meta packages
${red}  -R,  remove         ${reset}- remove packages
${red}  -La, list-avaiable  ${reset}- list avaiable packages based on package names
${red}  -Lc, list-cache     ${reset}- list downloaded packages in cache
${red}  -Li, list-installed ${reset}- list installed packages
${red}  -Po, out-cache      ${reset}- list packages out-cache
${red}  -Pi, in-cache       ${reset}- list downloaded packages in cache
${red}  -Qi, show           ${reset}- show package details
${red}  -Qq, total          ${reset}- total packages installed
${red}  -V,  version        ${reset}- output version information and exit
${red}  --nocolor           ${reset}- remove color from output
${red}  --table             ${reset}- output in columns
${red}  --verbose           ${reset}- verbose output
${cyan}ex:
  ${reset}fetch ${pink}-Sy ${reset} self ${yellow}=> Update self fetch via internet
  ${reset}fetch ${pink}-Sy ${reset}      ${yellow}=> Update database
  ${reset}fetch ${pink}-Syy${reset}      ${yellow}=> Force update database
  ${reset}fetch ${pink}-S  ${reset}<package> [<...>] [--all] [--noconfirm] [--force] [--nodeps]
  ${reset}fetch ${pink}-R  ${reset}<package> [<...>] [--all] [--noconfirm] [--force]
  ${reset}fetch ${pink}-Su ${reset}[<package>] [<...>] [--all] [--nonconfirm] [--force]
  ${reset}fetch ${pink}-Ss ${reset}<package> [<...>] [--noconfirm] [--force] [--exact] [--nodeps]
  ${reset}fetch ${pink}-Li ${reset}[<package>] [<...>] [--all] [--exact]
  ${reset}fetch ${pink}-Sw ${reset}[<package>] [<...>] [--all] [--noconfirm] [--force]
  ${reset}fetch ${pink}-Qi ${reset}[<package> [<...>]]
  ${reset}fetch ${pink}-C  ${reset}[<packname-version-build>]
  ${reset}fetch ${pink}-Sm ${reset}<xorg> [--noconfirm] [--force]
  ${reset}fetch ${pink}-Sa ${reset}<package> [<...>] [--all] [--noconfirm] [--force] [--mtime=<n>] [--keep] [--default]
EOF
}

function sh_parseparam() {
#	local param="$@"
	local param="$*"
   local s
   local newparam

	LDEPS=$true
	LAUTO=$false
	LFORCE=$false
	verbose=1
	mtime=0
	SPLITPOS='4'
	LLIST=$false
	LEXACT=$false
	LALL=$false
	LSELF=$false
	LKEEP=$false
	LTIME=$false
	LSEARCHONLY=$true
	LSKIPERROR=$false
	LTABLE=$false
	LSHOW=$true

	for s in $param
   do
      [[ $(tolower "${s:0:8}") = "--mtime=" ]] && { LTIME=$true; mtime="${s:8}"; continue;}
      [[ $(tolower "${s}") = "--default"    ]] && { LTIME=$true; LKEEP=$true; LALL=$true; continue; }
      [[ $(tolower "${s}") = "--keep"       ]] && { LKEEP=$true; continue; }
      [[ $(tolower "${s}") = "self"         ]] && { LSELF=$true; continue; }
      [[ $(tolower "${s}") = "--self"       ]] && { LSELF=$true; continue; }
      [[ $(tolower "${s}") = "--nodeps"     ]] && { LDEPS=$false; continue; }
      [[ $(tolower "${s}") = "-y"           ]] && { LAUTO=$true; continue; }
      [[ $(tolower "${s}") = "--auto"       ]] && { LAUTO=$true; continue; }
      [[ $(tolower "${s}") = "--noconfirm"  ]] && { LAUTO=$true; continue; }
      [[ $(tolower "${s}") = "-f"           ]] && { LFORCE=$true; continue; }
      [[ $(tolower "${s}") = "--force"      ]] && { LFORCE=$true; continue; }
      [[ $(tolower "${s}") = "--noverbose"  ]] && { verbose=0; continue; }
      [[ $(tolower "${s}") = "--verbose"    ]] && { verbose=2; continue; }
      [[ $(tolower "${s}") = "--v"          ]] && { verbose=1; continue; }
      [[ $(tolower "${s}") = "--vv"         ]] && { verbose=2; continue; }
      [[	$(tolower "${s}") = "--vvv"        ]] && { verbose=3; continue; }
      [[ $(tolower "${s}") = "-v"           ]] && { verbose=1; continue; }
      [[ $(tolower "${s}") = "-vv"          ]] && { verbose=2; continue; }
      [[	$(tolower "${s}") = "-vvv"         ]] && { verbose=3; continue; }
      [[	$(tolower "${s}") = "-q"           ]] && { verbose=0; continue; }
      [[ $(tolower "${s}") = "--quiet"      ]] && { verbose=0; continue; }
      [[ $(tolower "${s}") = "off"          ]] && { LLIST=$false; continue; }
      [[ $(tolower "${s}") = "on"           ]] && { LLIST=$true; continue; }
      [[ $(tolower "${s}") = "--exact"      ]] && { LEXACT=$true; continue; }
      [[ $(tolower "${s}") = "all"          ]] && { LALL=$true; continue; }
      [[ $(tolower "${s}") = "--all"        ]] && { LALL=$true; continue; }
      [[ $(tolower "${s}") = "--skiperror"  ]] && { LSKIPERROR=$true; continue; }
      [[ $(tolower "${s}") = "--nocolor"    ]] && { sh_unsetvarcolors; continue;}
      [[ $(tolower "${s}") = "--table"      ]] && { LTABLE=$true; continue;}
		newparam+="$s "
   done
	sh_setLogPrefix
	sh_checkroot "$@"
	#shellcheck disable=SC2086
	init $newparam
}

init() {
  	while test $# -gt 0
	do
		case "${1}" in
			-Si|-S|install)								shift;LSEARCHONLY=$false;LLIST=$true;sh_install "$@";return;;
			-Sl|local)  									shift;sh_initinstallpkg "$@";exit;;
			-Sa|alienpkg)	  		   					shift;sh_alienpkg_main "$@";return;;
			-Sc|clean)  									shift;fetchpack_init "$@";exit;;
			-c|-C|create)					   			shift;sh_createpkg "$@";exit;;
			-Sg|-g|generate)							   shift;sh_generatepkg "$@";exit;;
			-Ss|search)	     								shift;LSHOW=$false;sh_search "$@";exit;;
			-Sy|update)										shift;sh_updaterepo "$@";exit;;
			-Syy|refresh)									shift;sh_update "$@";exit;;
			-Sm|--meta|meta) 		            		shift;sh_installmeta "$@";exit;;
			-R|remove) 										shift;sh_remove "$@";exit;;
			-Sw|download) 									shift;sh_download "$@";exit;;
			-Sr|recreate)									shift;LLIST=$true;sh_recreatefilepackagesinstalled;exit;;
			-Qq|total)									   shift;sh_totalpackagesinstalled;exit;;
			-L|list)    	 								shift;LLIST=$true;sh_list "$@";exit;;
			-La|avaiable) 									shift;LLIST=$true;sh_list "$@";exit;;
			-Lc|list-cache) 	        					shift;LLIST=$true;sh_pkgincache "$@";exit;;
			-Pi|in-cache) 	        						shift;LLIST=$true;sh_pkgincache "$@";exit;;
			-Li|list-installed)							shift;LLIST=$true;sh_listinstalled "$@";exit;;
			-Po|out-cache)	            				shift;LLIST=$true;sh_pkgoutcache "$@";exit;;
			-Qi|show) 										shift;sh_show "$@";exit;;
			-Su|upgrade)									shift;sh_upgrade "$@";exit;;
      	-V*|--version|version)						logo;exit 0;;
      	-f*|--force)									LFORCE=1;;
      	-y*|--auto)										LAUTO=1;;
      	-exact|--exact)								LEXACT=1;;
      	-q|--quiet)										verbose=0;;
      	--nocolor)										sh_unsetvarcolors;;
      	--table)											LTABLE=1;;
      	-v*|--no-verbose|--verbose)				debug aqui; (( ++verbose ));test "${1:0:5}" = "--no-" && verbose=0;;
      	-h|--help)										usage;exit $(( $# ? 0 : 1 ));;
      	*)													die "operation not supported: $1 (use -h for help)";;
		esac
		shift
	done
}

parsestdin() {
	file=${1--} # POSIX-compliant; ${1:--} can be used either.
	IFS=$'\n'
	while read -r line; do
		echo "$line"
		init -a "$line"
	done < /dev/stdin
	#done < <(cat -- "$file")
	#done < <(cat /dev/stdin)
	#done < /dev/stdin
	#done < <(cat "$@")
}

sh_setvarcolors
[[ -z "${1-}" ]] && die "no operation specified (use -h for help)"
[[ "$1" = @(-H|-h|help|-help|--help) ]] && { usage; exit $(( $# ? 0 : 1 ));}
[[ "$1" = @(-V|-v|version|-version|--version) ]] && { logo; exit $(( $# ? 0 : 1 ));}

cleanup() {
	echo
 	echo "Interrupt signal received"
	log_msg "${pink}Cleaning...${reset}"
	cp -f "$TMP_DIR_BACKUP/*" "$CACHEDIR_SEARCH"/ >/dev/null 2>&-
	rm -rf "${TMP_DIR_ROOT:?}/" >/dev/null 2>&-
#	kill -TERM -$$
	exit 1
}
#trap "" 2 				# disable Ctlr+C
#trap    2  	 		# enable Ctlr+C
set -m
trap - INT
trap 'cleanup' 2 	# SIGINT SIGTERM SIGTSTP

sh_setEnvironment
checkDependencies
#sh_checkroot "$@"
sh_checkdir
sh_arraypkgfull "$CACHEDIR_SEARCH/$PACKAGES_SPLIT"
sh_parseparam "$@"

:<<'comment'
if [ -p /dev/stdin ]; then
	#for FILE in "$@" /dev/stdin
	for FILE in /dev/stdin
	do
		while IFS= read -r LINE
		do
			#echo "$LINE"
			init "$@" "$LINE"
		done < "$FILE"
	done
else
	# init "$@"
	sh_parseparam "$@"
fi
comment

# vim:set ts=3 sw=3 et:

# CodeBlock?
# Ponteiro=Var ; Var='Valor apontado'
# echo ${!Ponteiro}
